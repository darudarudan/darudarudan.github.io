<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<TITLE>だるだる団 DaruDaruDan プログラムメモ - (PC,Android,OpenGL)</TITLE>
</HEAD>
<BODY BGCOLOR="#000000" TEXT="#FFFFFF"LINK="#00CC88" VLINK="#0088CC">

<BR>
プログラムメモ<BR>
<BR><HR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/06/30 絵文字</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
気がついたら string.xml に絵文字を定義しても実行時に落ちなくなってた。<BR>
<BR>
Android Studio 2.2 で開発してた頃は確かダメだったハズ。<BR>
Android Studio 3.x のどこかで対応したのかな？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/04/08 Android NDK r20 bate2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r20 beta2 がリリース。<BR>
<BR>
何が変わったのかわからない…。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/04/08 Android NDK r20 bate2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r20 beta2 がリリース。<BR>
<BR>
何が変わったのかわからない…。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/03/14 Android NDK r20 bate1</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r20 beta1 がリリース。<BR>
<BR>
●Announcements (お知らせ)<BR>
・LLD を現在テスト中。<BR>
　AOSPはデフォルトでLLDを使用するように切り替えている作業中。<BR>
　リンク時に-fuse-ld = lldを渡して、アプリでLLDをテストしてください。<BR>
・Playストアは、2019年8月からAPKの64ビットのサポート必須になる。<BR>
　2019年8月からAPKをアップロードする場合、64ビットサポートが必要です。<BR>
　時が来たときに驚きを避けるために今すぐ移植を始めてください。<BR>
<BR>
●Changes (変更点)<BR>
・Updated Clang to r346389c.<BR>
・Add Android Q Beta 1 APIs:<BR>
　・MIDI (<amidi/AMidi.h>).<BR>
　・Binder.<BR>
　・以前のリリースからのいくつかのAPIへの拡張。<BR>
<BR>
●Known Issues　(既知の問題点)<BR>
これは、すべての未解決のバグの包括的なリストではありません。<BR>
<BR>
・Issue 360：静的STLを使用している場合にdlcloseedされているとsegfaultが発生する。<BR>
・Issue 70838247：Gold emitsがAArch64のデバッグ情報を破壊する。 <BR>
　BFDがデフォルトなのは変わらない。<BR>
・このバージョンのNDKはAndroid Gradleプラグインバージョン3.0以前と互換性がありません。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/02/16 Android NDK r19b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r19b がリリースされた。<BR>
<BR>
Issue 855:<BR> ndk-build automatically disables multithreaded linking for LLD on Windows, where it may hang. It is not possible for the NDK to detect this situation for CMake, so CMake users and custom build systems must pass -Wl,--no-threads when linking with LLD on Windows.<BR>
Issue 849:<BR> Fixed unused command line argument warning when using standalone toolchains to compile C code.<BR>
Issue 890:<BR> Fixed CMAKE_FIND_ROOT_PATH. CMake projects will no longer search the host's sysroot for headers and libraries.<BR>
Issue 907:<BR> Fixed find_path for NDK headers in CMake.<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/01/20 Android NDK r19</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r19 がリリースされた。<BR>
<BR>
beta2 から何が変わったんだろ？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2019/01/06 Android コンテキストの違い</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
LayoutInflater でレイアウトを読み込むと落ちる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android.view.InflateException: Binary XML file line #20: Error inflating class ImageView<BR>
</TD></TR>
</TABLE>
<BR>
散々調べてわかったのが attr を使ったレイアウトを読み込むと落ちている…。<BR>
えー。LayoutInflater って attr にアクセス出来ない？<BR>
<BR>
と思ってさらに調べたらコンテキストを getApplicationContext() から<BR>
this に変えたら落ちなくなった…。<BR>
<BR>
this と getApplicationContext() の Context は関連付けされる theme が<BR>
異なるのは聞いた事があったけど…まさかこんな感じで影響が出るとは思わなかった。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/12/07 Android NDK r19 beta2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r19 beta2 がリリース。<BR>
<BR>
変更点のどこが変わったかわかりにくいなぁ…<BR>
<BR>
・Updated Clang to r339409.<BR>
　　C++ compilation now defaults to C++14.<BR>
<BR>
<BR>
他。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/11/20 Android Studio 3.x で XML エラー。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio 3.x にアップデートすると発生する。<BR>
今まで参照に問題が無かった「?attr/xxx」などに <BR>
cannot resolve symbol theme というエラーが出る。<BR>
<BR>
Support Library バージョンが 27.1.0 の場合は 27.1.1 に変更する。<BR>
(それでも直らない場合は 28 系に変更する。)<BR>
<BR>
「android plugin for Gradle」のバージョン等が関連がしてるっぽい。<BR>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/11/09 Android NDK r19 beta1</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r19 beta1 がリリース。<BR>
<BR>
●Announcements (お知らせ)<BR>
・LLD をテスト用に使用できるようにした。<BR>
　次のリリースでAOSPはデフォルトでLLDを使用するように切り替わる。<BR>
　リンク時に-fuse-ld = lldを渡して、アプリでLLDをテストしてください。<BR>
・Playストアは、2019年8月からAPKの64ビットのサポート必須になる。<BR>
・Issues 780：スタンドアロンツールチェーンが不要になった。<BR>
　ndk-build、CMake 等を使用している場合は変化はありません。<BR>
　サードパーティのビルドシステムの管理者にとって意味があります。<BR>
・ndk-depends が削除された。 <BR>
　ReLinkerは古いAndroidバージョンでのネイティブライブラリの<BR>
　読み込みの問題を解決する優れたソリューションだと考えています。<BR>
<BR>
●Changes (変更点)<BR>
・Updated Clang to r339409.<BR>
・Issues 780：NDK Tool Chain がClangディレクトリにインストールされるようになった。<BR>
・ndk-buildは、APP_ABIに存在しないABIのNDK_LIBS_OUTから<BR>
　アーティファクトを削除しなくなった。<BR>
・ndk-stackはPythonで書き直されました。<BR>
・Issues 776：LLDをより良くサポートするため、ndk-buildとCMakeはデフォルトで<BR>
　-Wl、 - fix-cortex-a8 を渡しません。<BR>
・Issue 798：RelROとnoexecstackを無効にするための<BR>
　ndk-buildとCMakeのオプションは無視されるようになった。<BR>
　すべてのコードはRelROと実行不可能なスタックで構築されています。<BR>
・Issues 294：すべてのコードがコンパイラ-rtのサブセットでビルドされ、<BR>
Clang用のコンパイラ組み込み関数の完全なセットが提供されました。<BR>
<BR>
●Known Issues　(既知の問題点)<BR>
これは、すべての未解決のバグの包括的なリストではありません。<BR>
<BR>
・Issue 360：静的STLを使用している場合にdlcloseedされているとsegfaultが発生する。<BR>
・Issue 70838247：Gold emitsがAArch64のデバッグ情報を破壊する。 <BR>
　BFDがデフォルトなのは変わらない。<BR>
・このバージョンのNDKはAndroid Gradleプラグインバージョン3.0以前と互換性がありません。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/10/14 Android NDK r18b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r18b がリリース。<BR>
<BR>
Issue 799: Fixed build performance regression in ndk-build caused by compile_commands.json logic.<BR>
Issue 803: The "GCC" scripts in standalone toolchains now point to the correct Clang.<BR>
Issue 805: The "GCC" wrappers for Clang now use -gcc-toolchain.<BR>
Issue 815: ndk-build now builds with -fstack-protector-strong again.<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/08/28 Android Studio でエラーの原因がわからない。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Compilation failed; see the compiler error output for details.<BR>
とビルドログに出力された場合。<BR>
<BR>
メニューの「File」→「Settings」を選択。<BR>
左側の「Build, Excution, Deployment」→「Compiler」を選択。<BR>
「Command-line Options:」に --info を記述すると詳細な情報が出力されて<BR>
原因が分かる場合がある。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/09/19 Android NDK r18</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r18 がリリース。<BR>
<BR>
Announcements (Bate1 と同等)<BR>
・gcc は削除した。<BR>
・LLD をテスト用に使用できるようにした。<BR>
　AOSP はデフォルトで LLD を使用するように切り替えた。<BR>
・gnustl, gabi++ および stlport は削除した。<BR>
・ICS (android-14 and android-15) のサポートは削除した。<BR>
　PIE形式の違いを考慮する必要がなくなった。<BR>
・2019年８月からPlayストアに登録する apk は64ビットサポートが必須になります。<BR>
<BR>
Changes (追加あり)<BR>
・Clang を r328903 ベースの build 4751641 に更新した。<BR>
　Issue 573 が修正されて、-Oz のデフォルト最適化モードは thumb 命令になりました。<BR>
・libc++ を r334917 に更新した。<BR>
・ndk-build に clang-tidy のサポートを追加した。<BR>
・ndk-buildはJSONコンパイルデータベースを生成できるようになった。<BR>
・Issue 490：ndk-build と CMake は android-23（Marshmallow）以上をターゲットにすると<BR>
　ARM 用 NEON 命令をデフォルトで使用するようになりました。<BR>
・ndk-buildにAPP_STRIP_MODEとLOCAL_STRIP_MODEを追加した。<BR>
・Issue 749：NDKのlibc ++ _ shared.soはデバッグ情報を削除されなくなった。<BR>
<BR>
Known Issues<BR>
・Issue 360：静的STLを使用している場合にdlcloseedされているとsegfaultが発生する。<BR>
・Issue 70838247：Gold emitsがAArch64のデバッグ情報を破壊する。 BFDがデフォルトなのは変わらない。<BR>
・このバージョンのNDKはAndroid Gradleプラグインバージョン3.0以前と互換性がありません。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/09/06 Android NDK r17c</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r17c がリリース。<BR>
<BR>
変化点は１点だけ？<BR>
・Issue 112611166: Fixed "min" value in meta/platforms.json.<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/08/23 Android NDK r18 beta2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r18 beta2 がリリース。<BR>
<BR>
Changes<BR>
・Added APP_STRIP_MODE and LOCAL_STRIP_MODE to ndk-build.<BR>
・Issue 749: The libc++_shared.so in the NDK is no longer stripped of debug info.<BR>
　Debugging libc++ is now possible.<BR>
　Gradle will still strip the library before packaging it in an APK.<BR>
<BR>
他、不具合修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/08/17 Android Studio で NDK ビルド</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio で NDK を使ったビルドは CMAKE が推奨されている。<BR>
一応、ndk-build を使う事も可能だけど、将来は無くなる可能性が高い。<BR>
<BR>
build.gradle に記述する場合はこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
externalNativeBuild {<BR>
&ensp;&ensp;ndkBuild {<BR>
&ensp;&ensp;&ensp;&ensp;path "src/main/jni/Android.mk"<BR>
&ensp;&ensp;}<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
推奨される CMAKE の記述。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
externalNativeBuild {<BR>
&ensp;&ensp;cmake {<BR>
&ensp;&ensp;&ensp;&ensp;path "src/main/cpp/CMakeLists.txt"<BR>
&ensp;&ensp;}<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/08/04 アニメーションのＺオーダー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android の画面切り替えアニメーションは切り替え先が手前に表示される。<BR>
finish() で終了した場合は終了した画面が手前から消え、裏側画面が表示される。<BR>
<BR>
アプリの実装上、finish() ではなく intent で前の画面に戻りたい場合に問題が発生する。<BR>
<BR>
intent だと切り替え先と認識されるので表示中の画面が手前ではなく<BR>
裏側でアニメーションしてしまうので見た目がおかしくなる。<BR>
<BR>
この動作に気付けたのでなんとか解決策がみつかった。<BR>
<BR>
アニメーションには簡素なＺオーダー指定があってそれを使えばいい。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:zAdjustment="0"<BR>
<BR>
数字の意味は normal(0), top(1), bottom(-1) となる。<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/07/30 Android NDK r18 beta1</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r18 beta1 がリリース。<BR>
<BR>
Announcements<BR>
・gcc は削除した。<BR>
・LLD をテスト用に使用できるようにした。<BR>
　AOSP はデフォルトで LLD を使用するように切り替えた。<BR>
・gnustl, gabi++ および stlport は削除した。<BR>
・ICS (android-14 and android-15) のサポートは削除した。<BR>
　PIE形式の違いを考慮する必要がなくなった。<BR>
・2019年８月からPlayストアに登録する apk は64ビットサポートが必須になります。<BR>
<BR>
<BR>
Changes<BR>
・Clang を r328903 ベースの build 4751641 に更新した。<BR>
　Issue 573 が修正されて、-Oz のデフォルト最適化モードは thumb 命令になりました。<BR>
・libc++ を r334917 に更新した。<BR>
・ndk-build に clang-tidy のサポートを追加した。<BR>
・Issue 490：ndk-build と CMake は android-23（Marshmallow）以上をターゲットにすると<BR>
　ARM 用 NEON 命令をデフォルトで使用するようになりました。<BR>
・その他、不具合修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/07/28 乱数の初期化</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
乱数の初期化を時間関連の値で行っていると起きる問題。<BR>
<BR>
コードはこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
srand(GetTickCount());<BR>
</TD></TR>
</TABLE>
<BR>
レアケースなんだけど、バッチ処理等で同じアプリを複数起動すると、<BR>
１ミリ秒以下で複数起動されるので乱数のシードが全て同じになってしまう。<BR>
<BR>
よって各アプリの rand() で得られる値が全て同じになる…<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/07/22 Android Studio で NDK</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio に NDK を使った eclipse プロジェクトをインポートしてみた。<BR>
<BR>
やっぱり NDK 部分でエラーが出た。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Error:Execution failed for task ':app:compileDebugNdk'.<BR>
> Error: Your project contains C++ files but it is not using a supported native build system.<BR>
Consider using CMake or ndk-build integration with the stable Android Gradle plugin:<BR>
 https://developer.android.com/studio/projects/add-native-code.html<BR>
or use the experimental plugin:<BR>
 http://tools.android.com/tech-docs/new-build-system/gradle-experimental.<BR>
</TD></TR>
</TABLE>
<BR>
build.gradle に記述していなくても android.mk があると上記のエラーが出るみたい。<BR>
<BR>
対処としては SDK Maneger で CMAKE を追加ダウンロード。<BR>
cmakelists.txt 作成して android.mk と置き換えればいい。<BR>
<BR>
そのまま android.mk を使いたい場合は gradle.properties を作成して<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android.useDeprecatedNdk=true<BR>
</TD></TR>
</TABLE>
<BR>
を記述すれば、build.gradle で android.mk を指定してビルドできる。<BR>
<BR>
ただし、android.mk は将来的にサポートされなくなるので<BR>
CMAKE に移行する事が勧められている。<BR>

<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/06/16 VC カスタムビルドの nasm でエラー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
カスタムビルドで nasm を使ったVCプロジェクトを移動してビルドしたらエラーになった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
nasm: error: more than one input file specified<BR>
</TD></TR>
</TABLE>
<BR>
入力ファイルが異常だと言われているみたいだけど…<BR>
<BR>
移動後のフォルダ名にスペースが入っているのでファイル名解析で失敗してるっぽい。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
nasmw -dWIN32 -f win32 -o "$(IntDir)\$(InputName).obj" "$(InputDir)/$(InputName).asm"<BR>
</TD></TR>
</TABLE>
<BR>
ダブルクォーテーションで囲んだら解決した。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/06/13 Android NDK r17b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r17b がリリース。<br>
バグ修正がメインかなー。<BR>
<BR>
Issue 480: Fixed libc++ header issues with _FILE_OFFSET_BITS=64.<BR>
Issue 692: Fixed ASAN for standalone toolchains with static STLs.<BR>
Issue 697: Pulled documentation updates for simpleperf.<BR>
Issue 702: Updated sysroot to fix missing libc symbols.<BR>
Issue 704: Updated shaderc/vulkan-validation-layers sources.<BR>
Issue 708: Fixed introduced API tag for pthread_cond_timedwait_monotonic_nmp to make it available on ICS.<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/06/02 Android Studio で NDK を試してみる</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio でも NDK を問題なく使用できる。<BR>
<BR>
Eclipse 時代のソースもビルド出来るけど問題なのはメイクファイル。<BR>
今までと互換性が無い CMAKE が採用されている。<BR>
<BR>
一応、build.gradle で android.mk をビルドできるけど、<BR>
細かい事をやろうとすると面倒そうだし、将来使えなくなる可能性もあるので<BR>
CMAKE に対応して置いた方が良さそう。<BR>
<BR>
なんとなく android.mk と cmakelists.txt を一緒にビルドを<BR>
試してみたけど混合はビルドできないみたい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/05/28 Android Studio 3.1 のバグ？</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
某所より Android Studio 用のプロジェクトをダウンロードしてインポートしたら<BR>
ツリーに build.gradle (project名) が表示されていない…<BR>
<BR>
いろいろ調べた結果、.idea/modules.xml に記述されるパスが正しくない。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
正：fileurl="file://$PROJECT_DIR$/TestProject.iml" filepath="$PROJECT_DIR$/TestProject.iml"<BR><BR>
誤：fileurl="file://$PROJECT_DIR$/.idea/TestProject.iml" filepath="$PROJECT_DIR$/.idea/TestProject.iml"<BR>
</TD></TR>
</TABLE>
<BR>
なぜか .idea フォルダにプロジェクトの iml が生成されるようになっているので<BR>
プロジェクトルートにある build.gradle を参照しなくなっているのが原因だった。<BR>
手動で .idea/modules.xml を修正して直ったけど、これってバグだよね？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/05/09 Android NDK r17 </FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
突然 Android NDK r17 がリリース。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/05/06 Proguardで難読化されたログから名称を復元する</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
難読化しているとスタックトレースのどこで例外が発生したのかわからない。<BR>
<BR>
どうやら難読化したログを mapping.txt として保存してるらしく、<BR>
このファイルから元の名称を復元できるらしい。<BR>
<BR>
Android SDK 中にある tools/proguard/bin/retrace.bat を使って復元する。<BR>
※Windows 以外の環境だと retrace.sh を使う。<BR>
<BR>
やり方は難読化前の名称にしたいスタックトレースを stacktrace.txt として保存して<BR>
下記コマンドを実行すればクラス名やメソッド名に置き換えてくれる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
retrace.bat （パス）\app\build\outputs\mapping\release\mapping.txt stacktrace.txt<BR>
</TD></TR>
</TABLE>
<BR>
完全では無いけど解析が楽になったかな。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/05/01 また CreateProcess か…</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android アプリを ndk でビルドしたらまた訳の分からないエラーが出た…<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
make (e=87): パラメーターが間違っています。<BR>
</TD></TR>
</TABLE>
<BR>
なんでも CreateProcess の第二引数（またか！）に制限があるらしく、<BR>
32,768 文字を超えるとダメらしい。<BR>
<BR>
プロジェクト側で生成されるメイクコマンドを修正して対応するしかない。<BR>
<BR>
パスをロングネーム（通常）ではなくショートネーム（DOS用等）で<BR>
扱う事によって文字数を減らす事ができるので設定を変更する。<BR>
<BR>
Application.mk に次の１行を追記する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
APP_SHORT_COMMANDS := true<BR>
</TD></TR>
</TABLE>
<BR>
Android.mk に次の１行を追記する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_SHORT_COMMANDS := true<BR>
</TD></TR>
</TABLE>
<BR>
この２つを追記してビルドが通るようになった。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/04/27 Proguard でスタックサイズエラー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Proguard を有効にすると解決が面倒な事ばかり起きる…。<BR>
<BR>
訳のわからないエラーが発生したのでいろいろ調べた。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Stack size becomes negative after instruction [23] invokestatic #58 in [com/google/android/gms/internal/zzap.zzf(Ljava/lang/String;)J]<BR>
</TD></TR>
</TABLE>
<BR>
解決方法は２つあった。<BR>
<BR>
対策１：-dontoptimize を指定して最適化を無効にする。<BR>
<BR>
対策２：Log 出力を削除対象としない。<BR>
Log クラスのメソッド呼び出しを削除していると部分をコメントアウト。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#-assumenosideeffects public class android.util.Log {<BR>
#    public static *** v(...);<BR>
#    public static *** d(...);<BR>
#    public static *** i(...);<BR>
#    public static *** w(...);<BR>
#    public static *** e(...);<BR>
#    public static *** wtf(...);<BR>
#}<BR>
</TD></TR>
</TABLE>
<BR>
google のライブラリが最適化を非推奨としているなんて情報もあってビミョー。<BR>
Android の ART 動作なら java を中間オブジェクトで処理していないハズなので<BR>
java バイナリの最適化をしなくても最適化されるのかも知れないけどね…。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/04/26 CreateProcess でハマる</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
久しぶりに Windows アプリを組んでみた。<BR>
<BR>
CreateProcessA だと問題ないのに CreateProcessW だと落ちる。<BR>
<BR>
原因不明だったけどなんとか解決した。<BR>
CreateProcessW に渡す第二引数が (TCHAR* p) だと落ちるが<BR>
(TCHAR p[]) だと落ちない事が判明。<BR>
<BR>
これって VC 以外のコンパイラでも発生するのかな？<BR>
気になるけどわざわざアセンブラで確認するのは面倒だなー。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/04/21 NumberPicker を使う</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NumberPicker の EditText で IME を表示しないようにする。<BR>
<BR>
xml の表記。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:descendantFocusability="blocksDescendants"<BR>
</TD></TR>
</TABLE>
<BR>
java で実装する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
numberPicker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/04/19 ImageView を固定色で塗りつぶし</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ImageView を固定色で塗りつぶしてみた。<BR>
<BR>
とりあえず<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
int color = getResources().getColor(R.color.colorWhite);<BR>
imageView.setColorFilter(color);<BR>
</TD></TR>
</TABLE>
<BR>
とすると次に setImageBitmap しても表示が変わらない。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
imageView.setColorFilter(null);<BR>
</TD></TR>
</TABLE>
で無効にしないと画像が表示されない。<BR>
<BR>
<BR>
これだと扱いが面倒なので違う方法を探す。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
int color = getResources().getColor(R.color.colorWhite);<BR>
imageView.setImageDrawable(new ColorDrawable(color));<BR>
</TD></TR>
</TABLE>
<BR>
これだと setImageBitmap して表示が変化する。<BR>
<BR>
setColorFilter はマスク的な使い方、<BR>
setImageDrawable は画像無しの場合に使のがいいのかも知れない。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/04/17 Android NDK r17 beta2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r17 beta2 がひっそりリリース（笑）<BR>
<BR>
Announcements<BR>
・libc++ は標準 STL として使われている。<BR>
　もし他の STL を使っている場合は libc++ に移行する事を勧める。<BR>
・gnustl と stlport は非推奨となり NDK r18 で削除される。<BR>
・ARMv5 (armeabi), MIPS, and MIPS64 のサポートを削除した。<BR>
・ICS (android-14 and android-15) のサポートは R18 で削除される。<BR>
・2019年8月からPlayストアに登録するには apk に 64bit対応が必要。<BR>
　その時が来る前に 64bit へ移植を始めてください。<BR>
<BR>
Changes<BR>
・Clang を r316199 をベースにした build 4691093 に更新。<BR>
・更新 gtest to upstream revision 0fe96607d85cf3a25ac40da369db62bbee2939a5.<BR>
・libandroid のサポートは長くない。<BR>
・プラットフォーム静的ライブラリ（libc.a、libm.aなど）を更新。<BR>
・NDK のリビジョンは CMAKE で次のように固定される。<BR>
　・ANDROID_NDK_REVISION: The full string in the source.properties file.<BR>
　・ANDROID_NDK_MAJOR: The major revision of the NDK. For example: the 16 in r16b.<BR>
　・ANDROID_NDK_MINOR: The minor revision of the NDK. For example: the b (represented as 1) in r16b.<BR>
　・ANDROID_NDK_BUILD: The build number of the NDK. This is 0 in the case of a local development build.<BR>
　・ANDROID_NDK_BETA: The beta version of the NDK. This is 0 for a stable release.<BR>
・ndk-build に APP_WRAP_SH のサポートが追加された。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/03/20 依存関係(gradle Ver 4 系)</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio 3 にプロジェクトを移行してみた。<BR>
<BR>
compile が deprecated になってて書き換える必要が…。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
implementation → モジュールに展開され結合される。<BR>
api → 従来の compile と同じ動作。<BR>
compileOnly → 従来の provided と同じ動作。<BR>
runtimeOnly → この依存関係は実行時にのみ、モジュールとその使用側で利用できる。<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/03/12 Android NDK r17 beta1</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
２回のリリース延期を経て、beta1 がリリース。<BR>
<BR>
clang の更新とか。バグフィックス。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/02/27 エディットテキストの下線の色を変える</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
とりあえずスタイルを記述する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
&lt;style name="MyCustomEditTextTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;<BR>
&ensp;&ensp;&lt;item name="colorControlNormal"&gt;#0000ff&lt;/item&gt;<BR>
&lt;/style&gt;<BR>
</TD></TR>
</TABLE>
<BR>
style="@style/MyCustomEditTextTheme" だけだと colorControl が<BR>
適用されないので app:theme="@style/MyCustomEditTextTheme" にも設定する。<BR>
(style と app:theme の両方に設定する。)<BR>
app:theme を使うには android.support.v7.widget.AppCompatEditText を<BR>
使う必要がある。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/02/14 XML で強制的に警告を表示しない方法</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
出来る限り使用するべきでは無いけど…必要な場合もある。<BR>
tools:ignore に無視したい警告の種別を記述する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
xmlns:tools="http://schemas.android.com/tools"<BR>
tools:ignore="MissingPrefix"<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/01/26 フォルダとファイル名が長いとエラーが出る</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
新しくプロジェクトをインポートしたらエラーが出てビルドできない…。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Error:com.android.builder.internal.aapt.AaptException<BR>
</TD></TR>
</TABLE>
調べると com.google.android.gms の内部で使われている<BR>
common_google_signin_btn_icon_light_focused.9<BR>
が正しくない場合に出るエラーらしいが…何かが違う。<BR>
<BR>
Windows の文字数限界 240 文字にフォルダ名が達して発生していたようで、<BR>
プロジェクトのフォルダ階層を減らしてインポートし直したらビルドが通った。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/01/20 ListView のアイテムにボタン配置すると onItemClick が呼ばれない</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ListView のアイテムにボタンを配置した xml を指定すると<BR>
アイテム本体のタップが反応しなくなる。<BR>
(onItemClick が呼ばれなくなる。)<BR>
<BR>
回避策としてアイテムの xml の親 Layout (ViewGroup) に下記の記述をすると解決する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:descendantFocusability="blocksDescendants"<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/01/19 CheckedTextView を使う。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
CheckedTextView の android:checkMark に設定できる値。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
?android:attr/listChoiceIndicatorSingle<BR>
?android:attr/listChoiceIndicatorMultiple<BR>
?android:attr/textCheckMark<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/01/06 Spinner を使う。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
リスト展開した時のリソース変更。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adapter.setDropDownViewResource(R.layout.item_spinner_radio_dropdown);<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/01/02 TextInputLayout</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
android.support.design.widget.TextInputLayout<BR>
<BR>
テキストのヒントを常時表示する為のパーツ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/12/24 View からはみ出して表示する</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
子 View を親 View からはみ出して表示するには<BR>
clipChildren と clipToPadding を使用する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
&lt;?xml version="1.0" encoding="utf-8"?&gt;<BR>
&lt;RelativeLayout<BR>
&ensp;xmlns:android="http://schemas.android.com/apk/res/android"<BR>
&ensp;android:layout_width="match_parent"<BR>
&ensp;android:layout_height="match_parent"<BR>
&ensp;android:padding="40dp"<BR>
&ensp;android:clipChildren="false"<BR>
&ensp;android:clipToPadding="false"<BR>
&ensp;android:background="@color/white"&gt;<BR>
<BR>
&ensp;&lt;LinearLayout<BR>
&ensp;&ensp;android:layout_width="match_parent"<BR>
&ensp;&ensp;android:layout_height="match_parent"<BR>
&ensp;&ensp;android:background="@color/colorPrimary"&gt;<BR>
<BR>
&ensp;&ensp;&lt;!-- はみだしたい View --&gt;<BR>
&ensp;&ensp;&lt;TextView<BR>
&ensp;&ensp;&ensp;android:layout_width="wrap_content"<BR>
&ensp;&ensp;&ensp;android:layout_height="wrap_content"<BR>
&ensp;&ensp;&ensp;android:layout_marginLeft="-20dp"<BR>
&ensp;&ensp;&ensp;android:text="Hello World!"<BR>
&ensp;&ensp;&ensp;android:padding="12dp"<BR>
&ensp;&ensp;&ensp;android:background="@color/colorAccent"/&gt;<BR>
<BR>
&ensp;&lt;/LinearLayout&gt;<BR>
&lt;/RelativeLayout&gt;<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/12/08 Android NDK r16b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r16b がリリースされた。<BR>
<BR>
・コンパイルのデフォルトを -Oz に戻した。<BR>
<BR>
更新内容これだけ？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/11/19 Android NDK r17</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
リリース予定。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR WIDTH="588" BGCOLOR="#008888">
<TD>Beta 1</TD>
<TD>December 2017</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Beta 2</TD>
<TD>Late January 2018</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Release</TD>
<TD>February 2018</TD>
</TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/11/15 Android NDK r16</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Beta2 でしばらく止まっていた Android NDK r16 がリリースされた。<BR>
<BR>
・古いヘッダーは削除され、共通化されたヘッダーはシンプルになった。<BR>
・gcc は削除されていないが対応しない。バックポートも受け入れない。<BR>
　r18 で libc++,gnustl 関連が安定した場合には不要な STL と共には削除される。<BR>
・libc++ はβ版が終わり、使用が好まれる。r17 ではデフォルトSTLになる。<BR>
　手動で異なる STL を選択するよりも libc++ で使う事を強く勧める。<BR>
・ARMv5（armeabi）、MIPS、およびMIPS64のサポートは非推奨になる。<BR>
　これらは r17 で取り除かれる。<BR>
・ndk-build と CMake は標準で libatomic をリンクする。<BR>
　もう手動の追加 -latomic は必要ない。<BR>
・ndk-build の clang コンパイラは静的解析をサポートした。<BR>
・Clang の標準を -Oz から -Os に変更した。gcc よりもサイズを小さくする。<BR>
・GCC はデフォルトでもう -Bsymbolic を使わない。<BR>
　多くの公開されたシンボルはあなたのバイナリサイズを大きくする。<BR>
・binutils を 2.27 に更新。aarch64 のミスコンパイルを防ぐ。<BR>
・CMake の互換性が向上した。<BR>
・ndk-stack は arm64 上の Darwin で動作する。<BR>
・Android O MR1 のネイティブ API を追加した。<BR>
・他、バグ修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2018/10/10 AppCompatActivity の判定</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
AppCompatActivity を判定する方法。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
&ensp;public static AppCompatActivity getAppCompActivity(Context context) {<BR>
&ensp;&ensp;if (context == null) return null;<BR>
&ensp;&ensp;&ensp;if (context instanceof AppCompatActivity) {<BR>
&ensp;&ensp;&ensp;&ensp;return (AppCompatActivity) context;<BR>
&ensp;&ensp;&ensp;} else if (context instanceof ContextThemeWrapper) {<BR>
&ensp;&ensp;&ensp;&ensp;return getAppCompActivity(((ContextThemeWrapper) context).getBaseContext());<BR>
&ensp;&ensp;}<BR>
&ensp;&ensp;return null;<BR>
&ensp;}<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/10/09 AppCompat 系の widget</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
AppCompatActivity を使うと各パーツは初期化で自動的に置き換えられている。<BR>
<BR>
AppCompatAutoCompleteTextView<BR>
AppCompatButton<BR>
AppCompatCheckBox<BR>
AppCompatCheckedTextView<BR>
AppCompatEditText<BR>
AppCompatImageButton<BR>
AppCompatImageView<BR>
AppCompatMultiAutoCompleteTextView<BR>
AppCompatRadioButton<BR>
AppCompatRatingBar<BR>
AppCompatSeekBar<BR>
AppCompatSpinner<BR>
AppCompatTextView<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/10/07 自動生成される activity ソース</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
eclipse でプロジェクトを作成していて気が付いた。<BR>
<BR>
プロジェクト作成時に自動生成される activity ソースは<BR>
「Minimum Required SDK」と「Target SDK」が異なると AppCompatActivity。<BR>
同じだと Activity になる。<BR>
<BR>
これによって style 関連の自動生成結果も変わってくる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/09/20 Release 版のログ出力</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio でリリース版にするとログ出力が見えなくなる対策。<BR>
<BR>
adb から直接拾うと見れる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb logcat<BR>
</TD></TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/09/18 リストの末端アニメーション</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
リストの先頭と最後に到達したと時のアニメーションを無効にする方法。<BR>
<BR>
java コードから制御する。API Level 9 から使える。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
listView.setOverScrollMode(View.OVER_SCROLL_NEVER);<BR>
</TD></TR>
</TABLE>
<BR>
ViewCompat にもある。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
ViewCompat.setOverScrollMode(viewPager, ViewCompat.OVER_SCROLL_NEVER);<BR>
</TD></TR>
</TABLE>
<BR>
xml から制御する方法。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:overScrollMode="never"<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/09/01 NDK で端末の API Level を取得する</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK で API Level を取得できないか調べてみた。<BR>
<BR>
java 側の API を呼ぶ方法。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
buildClass = (*env)->FindClass( env,"android/os/Build$VERSION" );<BR>
if( buildClass != NULL )<BR>
{<BR>
&ensp;&ensp;&ensp;&ensp;sdkIntFieldID = (*env)->GetStaticFieldID( env,buildClass, "SDK_INT","I" );<BR>
&ensp;&ensp;&ensp;&ensp;sdk_int = (*env)->GetStaticIntField( env,buildClass,sdkIntFieldID );<BR>
&ensp;&ensp;&ensp;&ensp;(*env)->DeleteLocalRef( env,buildClass );<BR>
}<BR>
LOGI( "build.sdk_int : %d\n",sdk_int );<BR>
</TD></TR>
</TABLE>
<BR>
<BR>
システム情報から文字列で取得する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#include &lt;sys/system_properties.h&gt;<BR>
int len;<BR>
char str[128];<BR>
<BR>
// シリアルナンバーを読む<BR>
len = __system_property_get(“ro.serialno”, str);<BR>
// 機種を読み取る<BR>
len = __system_property_get(“ro.product.model”, str);<BR>
// sdkバージョンを読み取る<BR>
len = __system_property_get(“ro.build.version.sdk”, str);<BR>
len = __system_property_get("ro.build.version.release", str);<BR>
</TD></TR>
</TABLE>
<BR>
こっちは古い API らしく Deprecated になっている。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#include &lt;cutils/properties.h&gt;<BR>
char str[128];<BR>
<BR>
// sdkバージョンを読み取る<BR>
property_get(“ro.build.version.sdk”, str , "0" );<BR>
</TD></TR>
</TABLE>
<BR>
NativeAcitivy の方法。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#include &lt;android/configuration.h&gt;<BR>
// sdkバージョンを読み取る<BR>
int sdk_int = AConfiguration_getSdkVersion( app->config );<BR>
LOGI( "build.sdk_int : %d",sdk_int );<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/08/11 Android のスレッドID</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
java と NDK で互換性のあるスレッドIDを取得する。<BR>
<BR>
java 側のスレッドIDを取得する方法。
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
int tid = android.os.Process.myTid();<BR>
</TD></TR>
</TABLE>
<BR>
NDK の場合は Linux の tid の取得する方法を使う。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#include &lt;unistd.h&gt;<BR>
pid_t tid = gettid();<BR>
</TD></TR>
</TABLE>
<BR>
取得した tid でプライオリティの変更が出来る。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/08/04 Android NDK r15c</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r15c がリリースされた。<BR>
<BR>
・_FILE_OFFSET_BITS=64 に関係する API を修正。(64bitファイルアクセス)<BR>
・termios.h の API を古い API として修正。(非推奨？)<BR>
・互換性を維持する為に ffs を追加した。ただし非推奨。<BR>
・過去のリリースとの互換性を取る為に古い pthread API を追加した。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/07/04 Android NDK r15b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r15b がリリースされた。<BR>
<BR>
・libsync のヘッダーとライブラリの不整合を修正。<BR>
・他のシステムとの互換性を高める為に libc ヘッダーを更新した。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/06/28 Android SDK 更新</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
eclpse でのサポートが無くなり Android アプリ開発がやりづらくなってるけど<BR>
そんな事を気にせず、 android SDK の更新してみた。<BR>
<BR>
とりあえずコンパイルは問題なさそう。次はデバッグ実行を…<BR>
<BR>
あれ？…エラーが出て実行できない。ついでに apk も作成できない…<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Dex Loader] Failed to load C:\android_sdk\build-tools\26.0.0\lib\dx.jar<BR>
TestApp] Unknown error: Unable to build: the file dx.jar was not loaded from the SDK folder!<BR>
</TD></TR>
</TABLE>
<BR>
いくつか素行錯誤したけど改善せず。<BR>
<BR>
追加された Build Tools が悪さしてるみたいだから 26.0.0 を削除して eclipse を再起動！<BR>
お…動いた。とりあえず 25.0.3 までは大丈夫みたい。<BR>
<BR>
eclipse だと最新の 26.0.0 は使えないのかな？<BR>
ADT を最新（配布終了？）に更新してれば動くなのかなぁ…？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/06/12 Android NDK r15</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r15 がリリースされた。<BR>
<BR>
Gingerbread (android-9) はサポートしない。<BR>
最小の API level は Cream Sandwich (android-14) になる。<BR>
x86 and x86-64 用のアセンブラ YASM を CMake toolchain で対応。<BR>
<BR>
・Android O.で追加された API を知って欲しい。<BR>
　AAudio API<BR>
　Hardware Buffer API<BR>
　Shared Memory API<BR>
・awk はもう長く使わない。Python に置き換えられる。<BR>
・Clang を build 4053586 に更新。元になったのは Clang 5.0 SVN r300080。<BR>
・Clang は OpenMP に今対応した。(MIPS/MIPS64を除く) <BR>
・libc++ の信頼性を高める為に libandroid_support を改善し、サイズダウンを行う。<BR>
・その他、バグ修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/06/10 Android の UIPageControl</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
iPhone には UIPageControl というページ状態を表す UI パーツがあるけど、<BR>
Android には存在しない。でも使ってるのは良く見かける。<BR>
（ViewPager なんかと合わせて使う「・●・・・」みたいなやつ。）<BR>
<BR>
Android ではアプリがみんな独自に実装してるっぽい。<BR>
こういうのをデザインサポートライブラリに入れればいいのにねぇ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/06/07 Android の UITableView</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
iPhone には UITableView を使ってリストの項目を左にスワイプすると<BR>
「削除」が出てきたりするけど、Androind には当然そんな UI パーツはない。<BR>
たまに Android でも使ってるのは見かけるけど、気が付かないよね。コレ。<BR>
<BR>
Android では iPhone をマネしてアプリが独自に実装してるっぽい。<BR>
こういうのをデザインサポートライブラリに入れればいいのにねぇ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/04/12 Android NDK r14b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r14b がリリースされた。<BR>
少数のバグ修正リリース。<BR>
<BR>
今後の gcc サポートは長くない。<BR>
<BR>
・XSIので『strerror_r』 統合されたヘッダーを持つアンドロイド23まで入手可能ではないのを修正。？<BR>
・Windows版の toolchains で __ANDROID_API__ が追加されていなかったのを修正。？<BR>
・mips32のためのスタンドアロンのtoolchainsによってgnustlヘッダーを見つけることができないのを修正。？<BR>
・偶然露出されたnon-NDK API Vulkanヘッダーを削除。<BR>
　非APIヘッダー自身の機能は暴露されなかった。従って、これらはとにかく使用可能ではなかった。<BR>・RTTIと例外は、デフォルトで現在オンである。<BR>
　これは、高められた互換性のために既存のCMakeプロジェクトによってされた。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/04/10 Android NDK r14</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r14 がリリースされた。<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/03/20 singleLine は本当にいらない？</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Deprecated になった singleLine の変わりとしてよく紹介されている<BR>
項目の値を設定をしても期待した動作にならない事が多くて困る。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:lines="1"<BR>
android:maxLines="1"<BR>
android:minLines="1"<BR>
android:scrollHorizontally="true"<BR>
</TD></TR>
</TABLE>
<BR>
singleLine を呼ぶと内部で何かのフラグを立てるらしいけど、<BR>
他の設定に置き換えてもそのフラグが立たないらしい。それが原因？<BR>
どうにかならないのかなぁ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/03/17 TextView#setText で落ちる</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 2.3 の端末だと問題ないのに 4.4 と 5.0 だと<BR>
TextView#setText を実行して落ちる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
java.lang.ArrayIndexOutOfBoundsException: length=49; index=-1<BR>
&ensp;&ensp;&ensp;&ensp;at android.text.StaticLayout.calculateEllipsis(StaticLayout.java:679)<BR>
&ensp;&ensp;&ensp;&ensp;at android.text.StaticLayout.out(StaticLayout.java:643)<BR>
&ensp;&ensp;&ensp;&ensp;at android.text.StaticLayout.generate(StaticLayout.java:427)<BR>
&ensp;&ensp;&ensp;&ensp;at android.text.StaticLayout.<init>(StaticLayout.java:144)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.makeSingleLayout(TextView.java:6484)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.makeNewLayout(TextView.java:6330)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.checkForRelayout(TextView.java:6869)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.setText(TextView.java:4086)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.setText(TextView.java:3944)<BR>
&ensp;&ensp;&ensp;&ensp;at android.widget.TextView.setText(TextView.java:3919)<BR>
</TD></TR>
</TABLE>
<BR>
ソースを確認してもおかしい部分はない…。<BR>
calculateEllipsis って出てるから省略文字の計算で失敗してる？<BR>
<BR>
とりあえずググったら singleLine を入れろとあったので試してみた。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:lines="1"<BR>
android:ellipsize="start"<BR>
android:singleLine="true"<BR>
</TD></TR>
</TABLE>
<BR>
落ちなくなった…これってOSの不具合なんじゃないかと。<BR>
<BR>
singleLine は <FONT COLOR="#ff0000">Deprecated</FONT> なんだけど、使わないと正常に動かないケース多過ぎ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/02/26 NDK の sprintf で SJIS が使えない</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
新しい端末が手に入ったのでアプリを動かしたら文字列が表示されないバグを発見。<BR>
<BR>
原因を調べると sprintf が 0 を返して文字列をバッファに入れていなかった。<BR>
Android 5.0 以降では sprintf で文字列に SJIS が含まれると処理を中断するように<BR>
なっていたようだ。<BR>
<BR>
対策としてはソースを UTF-8 にすること。<BR>
何らかの理由で取得するデータが SJIS の場合は UTF-8 に変換してから<BR>
sprintf に渡して文字列を形成する。<BR>
<BR>
かなり面倒だけど sprintf を自作する方法もある。<BR> 
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/02/16 Android Studio 2.2.3</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio 2.2.3 で「Instant Run」を使ってアプリ作成してて気づいた。<BR>
たまに実行しても修正内容が反映されて無い時がある…<BR>
<BR>
どうも xml の修正は反映されないっぽい？<BR>
<BR>
そんな時は端末の USB ケーブルを抜き差しすると改善されるけど面倒だなぁ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/02/08 リスト選択のアニメーション2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ListView の項目をタップした時の波紋アニメーションを使用する方法。<BR>
<BR>
当然だけど、Android バージョンによって動作しない。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
「android:background="?attr/selectableItemBackground"」<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/02/06 リスト選択のアニメーション</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ListView の項目をタップした時のアニメーションを他のパーツに適用する方法。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:background="@android:drawable/list_selector_background"<BR>
</TD></TR>
</TABLE>
<BR>
これは OS 側で用意されている設定なので Android のソースを参照すれば中身が見れる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
frameworks/base/core/res/res/drawable/<BR>
</TD></TR>
</TABLE>
<BR>
アニメーションだとこっちのパス。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
/frameworks/base/core/res/res/anim/<BR>
</TD></TR>
</TABLE>
<BR>
当然だけど参照するソースの Android バージョンによって内容が違う可能性がある。<BR>
<BR>
<BR>
ListView の標準の Selecter はこれらしい。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
「android:background="?android:attr/activatedBackgroundIndicator"」<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/01/27 onActivityResult の引数</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android では前の画面から戻ってきた場合に onActivityResult が呼ばれる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
@Override<BR>
void onActivityResult(int requestCode, int resultCode, Intent intent)<BR>
</TD></TR>
</TABLE>
<BR>
requestCode は startActivityForResult(intent,REQUEST_CODE) の第二引数を返す。<BR>
resultCode は setResult(RESULT_OK,intent) の第一引数を返す。<BR>
intent は setResult(RESULT_OK,intent) の第二引数を返す。<BR>
<BR>
resultCode は下記の値(int 型)が使用できる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR WIDTH="588" BGCOLOR="#008888">
<TD>RESULT_CANCELED</TD>
<TD>0</TD>
<TD>キャンセルされた</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>RESULT_FIRST_USER</TD>
<TD>1</TD>
<TD>自分で定義する結果コードの最初の値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>RESULT_OK</TD>
<TD>-1</TD>
<TD>結果成功</TD>
</TR>
</TABLE>
<BR>
独自の値も定義して使用できる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
final int RESULT_YES = RESULT_FIRST_USER + 0<BR>
final int RESULT_NO = RESULT_FIRST_USER + 1<BR>
final int RESULT_RETRY = RESULT_FIRST_USER + 2<BR>
</TD></TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2017/01/22 Android Studio のビルド切り替え</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio でビルド (Debug, Release) を切り替えるにはウインドウの<BR>
左側にある縦型タブの下側にある「Build Variants」をクリックする。<BR>
これでデバッグとリリースを切り替えれるウインドウが表示される。<BR>
<BR>
もしくはメニューの「Build」→「Select Build Variant...」を<BR>
選択しても切り替えウインドウが表示される。<BR>
<BR>
また、build.gradle を修正して Build Variant を増やせる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android {<BR>
&nbsp;&nbsp;...(省略)<BR>
<BR>
&nbsp;&nbsp;productFlavors {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;develop {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applicationId "com.develop.testapp"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;versionName "1.0.0 (dev)"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;products {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applicationId "com.products.testapp"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;versionName "1.0.0"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
上記修正を加えると Build Variant は４つに増える。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
developDebug<BR>
developRelease<BR>
productsDebug<BR>
productsRelease<BR>
</TD></TR>
</TABLE>
<BR>
ソースも別々に読み込ませることも可能になる。<BR>
※ただし、AndroidManifest.xml だけは結合されるので注意すること！<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
src\main\　　共通のソースコード<BR>
src\main\develop　　develop 用のソースコード<BR>
src\main\products　　products 用のソースコード<BR>
</TD></TR>
</TABLE>
<BR>
直接パスを記述する事も可能。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android {<BR>
&nbsp;&nbsp;...(省略)<BR>
<BR>
&nbsp;&nbsp;sourceSets {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;main {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.srcDirs = ['src/main/java']<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.srcDirs  = ['src/main/res']<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;develop {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.srcDirs = ['src/demo/java']<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.srcDirs  = ['src/demo/res']<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/12/29 Android.mk のパスを指定する</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ndk-build を実行すると jni フォルダの中にある Android.mk が処理される。<BR>
<BR>
Android.mk 以外のファイルを指定したい場合や jni フォルダ以外を対象にもできる。<BR>
<BR>
パッケージ名が TestApp ならこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
ndk-build APP_BUILD_SCRIPT=$(APP_PROJECT_PATH)/TestApp/jni/Android.mk<BR>
</TD></TR>
</TABLE>
<BR>
これは最初に読み込むメイクファイルを指定する方法なので、<BR>
include $(call all-subdir-makefiles) を使ってサブフォルダを検索するケースでは<BR>
サブフォルダ内の Android.mk 以外を指定する事はできない。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/11/01 Android NDK r13b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r13b がリリースされた。<BR>
少数のバグ修正リリース。<BR>
<BR>
今後の gcc サポートは長くない。<BR>
<BR>
・simpleperf を追加した。これは Android 用の CPU プロファイラ。<BR>
・__cxa_bad_cast の間違いを修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/10/07 Android NDK r13</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r13 がリリースされた。<BR>
ビルド環境の移行および修正。<BR>
<BR>
今後の gcc サポートは長くない。<BR>
<BR>
・NDK_TOOLCHAIN_VERSION の標準を Clang に変更した。<BR>
・libc++ を r263688 にアップデートした<BR>
・make-standalone-toolchain.sh は Python 版をラップした簡単なもの。<BR>
・サポートしないABIのライブラリを削除。(mips64r2, mips32r6, mips32r2, 32bitMIPS)<BR>
<BR>
C++ライブラリの例外補足は ARM の Gingerbread および Ice Cream Sandwichで<BR>
動作しない。これらは Marshmallow and N で提供される？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/09/14 Android で低レイテンシの再生</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
特に興味は無いんだけど Android 4.2 から低レイテンシの再生に対応していたらしい。<BR>
<BR>
ただし、低遅延で動作させるには条件があり、ハード側（端末）だけでなく<BR>
ソフト側でも下記条件を考慮する必要がある。<BR>
<BR>
1. 指定されたサンプリング周波数で再生する。(最近だと 48KHz)<BR>
2. 指定されたサンプル数の倍数でバッファを構成する。<BR>
3. エフェクトを使用しない。<BR>
<BR>
端末や OS バージョンに依存するかも知れないけど、<BR>
１と３は必須で考慮しなければ低遅延の動作モードにならない。<BR>
　※48KHz の場合に 44.1KHz を使うのは NG。未確認だけど 96KHz は OK らしい。<BR>
２に関しては守れば＋αで低遅延になるっぽい。影響度は低い。<BR>
<BR>
AudioManager の getProperty から上記に関連する値を取得できる。<BR>
　※文字列での取得になるので整数型への変換が必要。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
AudioManager am;<BR>
String str;<BR>
am = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);<BR>
str = am.getProperty(AudioManager.OUTPUT_SAMPLE_RATE);<BR>
str = am.getProperty(AudioManager.OUTPUT_FRAMES_PER_BUFFER);<BR>
</TD></TR>
</TABLE>
<BR>
OpenSL ES の場合は３を考慮する為に CreateAudioPlayer で<BR>
SL_IID_ANDROIDSIMPLEBUFFERQUEUE, SL_IID_PLAY だけを指定する。<BR>
SL_IID_EQUALIZER を追加すると低遅延モードにならない。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/07/02 Android NDK r12b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r12b がリリースされた。<BR>
小規模なバグ修正。<BR>
<BR>
・ndk-gdb.py を修正。<BR>
・NdkCameraMetadataTags.h を更新。<BR>
・ndk-build のバグで libc++ 使用時の正しくない警告を修正。<BR>
・android-24 の OpenSLES ヘッダを更新。<BR>
<BR>
ARM Hard Float ABI Removal<BR>
https://android.googlesource.com/platform/ndk/+/ndk-r12-release/docs/HardFloatAbi.md<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/07/01 Android NDK r12 検証２</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
google の NDK ダウンロードの x86 と x64 が逆なのがやっと直ってた。<BR>
<BR>
前回の e=216 の原因はツールチェインの指定が原因だった…。<BR>
<BR>
Application.mk から次の２行を消す。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
APP_ABI := armeabi-v7a-hard<BR>
NDK_TOOLCHAIN_VERSION=clang<BR>
</TD></TR>
</TABLE>
<BR>
これでビルドが通るようになった。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/06/20 Android NDK r12 検証</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
google の NDK ダウンロードのファイルが x86 と x64 が逆になってる…<BR>
とりあえず 64bit の方の x86 をダウンロード。<BR>
<BR>
armeabi-v7a-hard のビルドチェック。<BR>
やっぱりエラーになった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Android NDK: armeabi-v7a-hard is no longer supported. Use armeabi-v7a.<BR>
Android NDK: See https://android.googlesource.com/platform/ndk/+/master/docs/Har<BR>
dFloatAbi.md<BR>
Android NDK: NDK Application 'local' targets unknown ABI(s): armeabi-v7a-hard<BR>
<BR>
Android NDK: Please fix the APP_ABI definition in C:/eclipse/workspace/testjni2/<BR>
jni/Application.mk<BR>
c:/android_ndk/build//../build/core/setup-app.mk:120: *** Android NDK: Aborting<BR>
</TD></TR>
</TABLE>
<BR>
<!--
NDK r12 では arm v5 を切り捨てたので FPU を搭載しないＣＰＵが存在しなくなり、<BR>
hard-fp がデフォルトになったので armeabi-v7a-hard は無くなった？<BR>
ドキュメントを見ると soft-fp の記述しかないし…。<BR>
-->
とりあえず armeabi-v7a-hard を外すとまたしてもエラー。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
[armeabi-v7a] Compile thumb  : testjni <= testjni.c<BR>
process_begin: CreateProcess(ほにゃらら) failed.<BR>
make (e=216): Error 216<BR>
make: *** [C:/eclipse/workspace/core/dw_plug/obj/local/armeabi-v7a/objs/testjni/<BR>
testjni.o] Error 216<BR>
</TD></TR>
</TABLE>
<BR>
これって x86 パッケージの中に x64 バイナリが混ざっているってことじゃないかと。<BR>
NDK r12a が出るのは確定ですか。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/06/18 Android NDK r12</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r12 がリリースされた。<BR>
今回の修正内容は互換性にも大きく影響する。<BR>
<BR>
・Clang を 3.8svn (r256229, build 2812033) に更新。<BR>
・Clang が標準になって、次回リリースより gcc は削除される。<BR>
・make-standalone-toolchain.sh は削除される。<BR>
　代わりに make_standalone_toolchain.py を使って欲しい。<BR>
・armeabi-v7a-hard ABI は削除された。詳しくはドキュメント参照。<BR>
・Android 2.3.3 (API Level 10) は削除された。<BR>
・使用できない ARM (non-thumb)用の STL libraries は削除された。<BR>
・android-24 で Vulkan サポート。<BR>
・android-24 で Choreographer API サポート。<BR>
・libcamera2 APIs は INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED を<BR>
　サポートした機器用。詳しくは CameraCharacteristics を参照。<BR>
・その他いろいろ。<BR>
<BR>
<BR>
Android 2.2 (API Level 8) 以下のサポートが無くなったので古いアプリのビルドは不可。<BR>
Android 2.3.1 (API Level 9) は残っている。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/04/02 Android NDK r11c</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
今回も変更は少なくてスクリプト系の修正。<BR>
Windows-32bit環境のツールチェインパスが修正されたのでビルドエラーが直った。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/03/26 Android NDK r11b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
変更は少なくてスクリプト系の修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/03/12 Android NDK r11 のバグ？</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
早速 Android NDK r11 を使ってみると問題が発生。<BR>
<BR>
ビルドを実行するとなぜかエラーになる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
failed.<BR>
make (e=3): wｳｽpXｪｩﾂｩﾜｹB<BR>
</TD></TR>
</TABLE>
<BR>
どうも参照しているパスが存在しないっぽい。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
ndk-build で gcc の参照しているパス<BR>
C:\android-ndk-r11\toolchains\arm-linux-androideabi-4.9\prebuilt\<FONT COLOR="#ff0000">windows-x86</FONT><BR>
<BR>
実際のパス構成<BR>
C:\android-ndk-r11\toolchains\arm-linux-androideabi-4.9\prebuilt\<FONT COLOR="#ff0000">windows</FONT><BR>
</TD></TR>
</TABLE>
<BR>
とりあえず参照パスと同じになるようにフォルダ名に -x86 を<BR>
付けたらビルドが失敗しないようになった。<BR>
<BR>
Clang の場合はこちら。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
C:\android_ndk\toolchains\llvm\prebuilt\windows-x86
</TD></TR>
</TABLE>
<BR>
64bit環境だと -x64 になるのかなぁ？<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/03/10 Android NDK r11</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 6.0 発表の時はスルーされたけど、N 発表でやっとNDKが更新された。<BR>
<BR>
コンパイラは GCC ではなく Clang が推奨らしい。<BR>
バグがあったら報告してくれだそうな。<BR>
<BR>
・Clang を 3.8svn (r243773, build 2481030) に更新。<BR>
・GCC は非推奨。5.0 にはアップデートしない。バックポートもしない。<BR>
・GCC 4.8 を削除。GCC 4.9 だけ使用可能。<BR>
・android-23 に tracing API, multinetwork API を追加。<BR>
・Vulkan のヘッダとライブラリ (API level N.)<BR>
・ドキュメントは含まれないので Web サイトを参照。<BR>
・その他いろいろ<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/02/09 Android Studio 2.0 Beta</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
2015/11 に発表された Android Studio 2.0 Preview 版が<BR>
Android Studio 2.0 Beta になってダウンロード可能に。<BR>
<BR>
差分ビルド＆実機転送で高速に実行できる「Instant Run」が特徴なのは変わらず<BR>
Preview 版からの新規の追加機能は特に無いみたい。<BR>
<BR>
Android のエミュレータは新しくなっているらしい。<BR>
<BR>
Ver 1.x は安定しているように思えなかったから使うのはパスしたけど、<BR>
正式版になったらまた試してみようかなー。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2016/01/02 printf を使うとエラーになる</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Visual Studio 2013/2012 で sprintf を使うとセキュリティの問題があるとエラーになる。<BR>
<BR>
VS2010 以前では警告が出るだけでエラーにはならなかったのに…。<BR>
<BR>
対処としてはセキュリティ強化版の sprintf_s を使うか、設定変更をする。<BR>
設定は「構成プロパティ」→「C/C++」→「SDLチェック」を<BR>
「いいえ (/sdl-)」に変更するとエラーではなく警告に変化する。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/12/20 Android NDK の ShiftJIS 対応</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK で ShiftJIS のビルド実験。<BR>
<BR>
ダメ文字「"表"、"ソ"」を含まなければビルドには問題ない。<BR>
<BR>
ダメ文字を含んだ状態でビルドする為に Android.mk に追記。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_CFLAGS += --input-charset=cp932
<BR>
</TD></TR>
</TABLE>
<BR>
これでビルドするとエラーが出る。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
cc1plus.exe: error: no iconv implementation, cannot convert from cp932 to UTF-8<BR>
</TD></TR>
</TABLE>
<BR>
このエラーは gcc が iconv に対応しないビルドで生成されると出るらしい。<BR>
NDK の gcc を iconv 対応でリビルドすれば対応可能なのかも知れない。<BR>
<BR>
<FONT COLOR="#ff0000">※Windows 版の NDK で発生する問題で Linux 版では発生しないらしい。</FONT><BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/12/11 Android 静的ライブラリのリンク</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK で jpeglib と libpng をビルドして普通にリンク。<BR>
<BR>
Android.mk の静的ライブラリのリンク指定は２種類ある。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_STATIC_LIBRARIES += libjpeg libpng<BR>
</TD></TR>
</TABLE>
<BR>
と<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_WHOLE_STATIC_LIBRARIES += libjpeg libpng<BR>
</TD></TR>
</TABLE>
<BR>
の２種類がある。<BR>
<BR>
LOCAL_WHOLE_STATIC_LIBRARIES を使うと生成されるバイナリのサイズが大きくなる。<BR>
この指定は未使用関数も全てリンクするオプションっぽい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/11/29 Android スリープ中の定期動作</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
スリープ中にタイマーは動作しない？インテントは受け取れない？<BR>
でもスレッドは動作している。<BR>
<BR>
ググると PendingIntent と AlarmManager とサービスを使う方法が紹介されている。<BR>
setInexactRepeating に AlarmManager.RTC_WAKEUP を指定して第３引数に<BR>
インターバルを指定すればできるっぽい。<BR>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/11/02 Assets からアプリ領域にコピー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Assets は専用 API で読み出し可能だが、書き換え不可やサイズ制限があるので<BR>
必要容量が大きくなってしまうがアプリ領域にコピーしてしまえば<BR>
これらの制限は無くなり、扱いやすくなる。<BR>
<BR>
で、コピーするコードをいくつか作ってみたけど、失敗したのを紹介。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
InputStream input = am.open( "data/" + arrStrPath[i] );<BR>
fcout = (new FileOutputStream(file)).getChannel();<BR>
ReadableByteChannel ch = Channels.newChannel(input);<BR>
fcout.transferFrom( ch,0,Long.MAX_VALUE );<BR>
</TD></TR>
</TABLE>
<BR>
ファイルは作成されるが、途中で例外が発生してサイズ0？<BR>
<BR>
さらにもう一つ。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
AssetFileDescriptor afd = null;<BR>
afd = am.openFd( "data/" + arrStrPath[i] );<BR>
file.createNewFile();<BR>
FileChannel src = new FileInputStream(afd.getFileDescriptor()).getChannel();<BR>
FileChannel dst = new FileOutputStream(file).getChannel();<BR>
long size = src .size();<BR>
</TD></TR>
</TABLE>
<BR>
size が Assets の全体サイズになる。コピーは Assets の塊ファイル。<BR>
<BR>
普通に InputStream と OutputStream でコピーするのが安全。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
input = am.open( strAssetsPath );<BR>
byte[] buffer = new byte[4096];<BR>
int read;<BR>
while( (read = input.read(buffer)) != 0 )<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;output.write( buffer,0,read );<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/10/22 Android setFlags と addFlags</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
setFlags と addFlags の違いが気になったので Android のソースを見てみた。<BR>
<BR>
/frameworks/base/core/java/android/view/Window.java<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
public void addFlags(int flags) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setFlags(flags, flags);<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
結局、setFlags が呼ばれるので結果は同じだった。<BR>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/10/21 Android GPU アクセラレーション有効確認。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
設定の「 GPU アクセラレーション」が無効の状態でアプリから<BR>
GPU アクセラレーションを使用にするのは３つの方法がある。<BR>
<BR>
1. AndroidManifest.xml に記述する。<BR>
2. Window に FLAG_HARDWARE_ACCELERATED を設定する。<BR>
3. View に View.LAYER_TYPE_HARDWARE を設定する。<BR>
<BR>
「GPU アクセラレーション」が有効か確認する API として<BR>
View#isHardwareAccelerated と Canvas#isHardwareAccelerated がある。<BR>
<BR>
View#isHardwareAccelerated は Window の FLAG_HARDWARE_ACCELERATED が<BR>
有効にされているかどうかで true,false を返す。<BR>
<BR>
よって、View.LAYER_TYPE_HARDWARE を設定したり、設定「GPU アクセラレーション」、 <BR>
AndroidManifest.xml のGPU設定を有効にしても true にはならない。<BR>
<BR>
Canvas#isHardwareAccelerated は常に false になる。<BR>
隠し API や API Lv 23 の lockHardwareCanvas を使うと true になるらしい。<BR>
<BR>
AndroidManifest.xml で有効にしたのを確認するには ActivityInfo を使う。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
PackageManager pm = getPackageManager();<BR>
ActivityInfo info = pm.getActivityInfo( getComponentName(),0 );<BR>
if( (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) &gt; 0 )<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/10/17 Android Bitmap 拡大縮小</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Bitmap を拡大縮小して Canvas に描画する方法は複数ある。<BR>
<BR>
これが一般的？<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Bitmap bitmap = 生成;<BR>
Paint paint = new Paint();<BR>
Rect rs = new Rect( 0,0,BMP_WIDTH,BMP_HEIGHT );<BR>
Rect rd = new Rect( px,py,scale_width+px,scale_height+py );<BR>
canvas.drawBitmap( bitmap,rs,rd,paint );<BR>
</TD></TR>
</TABLE>
<BR>
Matrix を使う方法。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Bitmap bitmap = 生成;<BR>
Paint paint = new Paint();<BR>
Matrix matrix = new Matrix();<BR>
matrix.setTranslate( px,py );<BR>
matrix.setScale( scale,scale );<BR>
canvas.drawBitmap( bitmap,matrix,paint );<BR>
</TD></TR>
</TABLE>
<BR>
BitmapDrawable を使う方法。<BR>
この拡大縮小にはアンチエイリアスが適用されるが処理が非常に重い。<BR>
必要に応じて drawable.setFilterBitmap( false ) で無効にする。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Bitmap bitmap = 生成;<BR>
BitmapDrawable drawable = new BitmapDrawable( bitmap );<BR>
drawable.setBounds( px,py,scale_width+px,scale_height+py );<BR>
drawable.draw( canvas );<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/10/12 Android のナビゲーションバー非表示</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ナビゲーションバー（Back,Home,Task のボタン領域）を非表示にする方法を探してみた。<BR>
Android 4.x 系で非表示に出来るけど画面タッチすると強制的に再表示される。<BR>
動画プレイヤーアプリとかならこれでも良いかも知れないけど…。<BR>
Android 5.x 系なら完全非表示が可能だとか。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
View view = getWindow().getDecorView();<BR>
view.setSystemUiVisibility( View.SYSTEM_UI_FLAG_HIDE_NAVIGATION );<BR>
</TD></TR>
</TABLE>
<BR>
試してみたけど Android 4.0 端末で非表示にならない…。<BR>
でも Android 4.3 端末では非表示になるのでコードは間違っていないみたい。<BR>
<BR>
API Level 14 ってなってるけど実際に使えるのは 15 なのかな？<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>バージョン</TD>
<TD>API Level</TD>
<TD>コードネーム</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 3.2</TD>
<TD>13</TD>
<TD>Honeycomb MR2</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 4.0</TD>
<TD ROWSPAN=3>14</TD>
<TD ROWSPAN=3>Ice Cream Sandwich</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 4.0.1</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 4.0.2</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 4.0.3</TD>
<TD>15</TD>
<TD>Ice Cream Sandwich MR1</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Android 4.1</TD>
<TD>16</TD>
<TD>Jelly Bean</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/10/10 Android NDK の SLresult</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK で OpenSL が使えるようになったのは Android 2.3(API Lv 9) から。<BR>
その時の SLresult の定義は unsigned long だった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
OpenSLES_Platform.h<BR>
typedef unsigned long sl_uint32_t;<BR>
<BR>
SLES/OpenSLES.h<BR>
typedef sl_uint32_t SLuint32;<BR>
typedef SLuint32 SLresult;<BR>
</TD></TR>
</TABLE>
<BR>
それがいつの頃からか API Level 14 以降で定義が変更になり<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
typedef unsigned long sl_uint32_t;<BR>
typedef signed long sl_int32_t;<BR>
</TD></TR>
</TABLE>
<BR>
から<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
typedef unsigned int /*long*/ sl_uint32_t;<BR>
typedef signed int /*long*/ sl_int32_t;<BR>
</TD></TR>
</TABLE>
<BR>
に変更された。<BR>
<BR>
int か long かの違いは 64bit 環境では 4byte,8byte と大きな違いがあるので<BR>
コンパイラのチェックが厳しくなっている。古いコードを新しい API Level に<BR>
変更すると警告が出てきたりと結構面倒。<BR>
<BR>
NDK の更新忘れのような気もするけど…。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/09/06 android sdk build-tools</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android SDK 22 からビルドツールが分離された。<BR>
<BR>
アップデートで問題があっても古いビルドツールが使えるようになっている。<BR>
project.properties に build-tools のバージョンを指定する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
sdk.buildtools=18.1.1<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/09/05 Android API 21</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 5.0 用のアプリを作ろうかと Android SDK Manager で<BR>
API Level 21 (5.0.1) を追加したけどエラーが出て APK が生成できない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
'Loading data for Android 5.0.1' has encountered a problem.<BR>
Parsing Data for android-21 failed<BR>
unsupported major.minor version 51.0<BR>
</TD></TR>
</TABLE>
<BR>
なんでも JAVA SDK を JDK 1.8 を入れないとダメらしい。<BR>
初期の頃は古い JDK 1.6 が推奨だったので少し驚き。<BR>
<BR>
JDK 1.8 を入れたら問題なく動いた。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/08/16 デフォルトライブラリがリンク出来ない</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VS2008 からランタイムライブラリの「シングルスレッド」が無くなり、<BR>
必ずマルチスレッドになるようになった。<BR>
<BR>
これによって古いVCでビルドした「シングルスレッド」の<BR>
スタティックライブラリを VS2008 で使おうとすると<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
「LINK : fatal error LNK1104: ファイル 'LIBC.lib' を開くことができません。」<BR>
</TD></TR>
</TABLE>
が発生してしまう。<BR>
<BR>
VS2008 の プロジェクト → プロパティ → 構成プロパティ → リンカ から<BR>
<BR>
入力 の「特定の既定のライブラリの無視」に「LIBC.lib」 を指定すると回避できる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/07/26 targetSdkVersion</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
AndroidManifest に記述した targetSdkVersion で動作や見た目が変わる。<BR>
<BR>
Android OS バージョンによってデフォルトのテーマ（背景色等）が異なる場合があるが、<BR>
targetSdkVersion が設定されていればバージョンが変わっても古いバージョンの<BR>
テーマが使用される。<BR>
targetSdkVersion が 8(Ver2.2) だとナビゲーションバーにメニューボタンが現れる。<BR>
<BR>
また、GC の動作が古い処理に置き換えられる事もあるらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/07/02 eclipse のヒープサイズ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
eclipse は java で動作しているので java で確保されたヒープ内で動作する。<BR>
その為、巨大なリソースを扱うプロジェクトではヒープが足りなくなり、<BR>
操作中に eclipse が突然、強制終了される事になる。<BR>
<BR>
そんな時は eclipse をインストールしたフォルダにある eclipse.ini を書き換える。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
-XX:PermSize=48m<BR>
-XX:MaxPermSize=512m<BR>
-Xms256m<BR>
-Xmx1024m<BR>
</TD></TR>
</TABLE>
-Xms は起動時に確保するヒープサイズ。<BR>
-Xmx はヒープが足りなくなった場合の拡大可能な最大サイズになる。<BR>
-XX:PermSize は起動時に確保するパーマネントサイズ。<BR>
-XX:MaxPermSize はパーマネントが足りなくなった場合の拡大可能な最大サイズになる。<BR>
<BR>
パーマネントはクラスファイルをメモリ上に展開する為の領域。<BR>
<BR>
eclipse が確保するメモリが足りないとGCが頻発して遅くなるが、<BR>
足りている場合は増やしても速くなる訳ではない。<BR>
<BR>
32bit版 Java で設定可能なヒープサイズは約 1.5GB でこれより大きな値を<BR>
指定すると起動しなくなる。64bit版ならこの制限は無い。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/07/01 Android 端末のヒープサイズ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 2.x 端末は１つのアプリに割り当てる最大ヒープサイズは大抵 24MB。<BR>
カメラで撮影した高解像の画像を扱うと大量のメモリを扱うので<BR>
 Bitmap クラスや ImageView が「Out of Memory」を起こしやすくなる。<BR>
画像処理アプリはヒープサイズが小さいと作るのも使うのも難しい。<BR>
<BR>
Android 4.x の最大ヒープサイズは 24～72MB と端末によって大きく異なる。<BR>
<BR>
メモリが少ない場合は Android 3.0 から追加された LARGE_HEAP を使うと<BR>
ヒープサイズは 128～256MB と激増する。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/06/19 Android タッチイベント</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
タッチイベントの初回は最上位の親 ViewGroup (RelativeLayout 等のレイアウト)の<BR>
dispatchTouchEvent から開始される。<BR>
<BR>
dispatchTouchEvent が呼ばれると ViewGroup の中にある配置的に優先度の高い<BR>
View もしくは ViewGroup から順番にイベントを渡していく。<BR>
対象が View なら onTourchEvent が呼ばれ、<BR>
ViewGroup なら dispatchTouchEvent が呼ばれる。<BR>
<BR>
ViewGroup の中の全ての View,ViewGroup が true を返さなければ<BR>
ViewGroup 自身の onTourchEvent が呼ばれる。<BR>
<BR>
true を返すか、View が無くなるまでこの処理を繰り返す。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/06/04 Android Timer のスレッドタイプ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Timer クラスのコンストラクタにはスレッドタイプを指示する boolean がある。<BR>
true ならデーモンススレッド、false ならユーザースレッドで動作する。<BR>
<BR>
デーモンスレッドはメインスレッドが終了したら強制的に終了、<BR>
ユーザースレッドはメインスレッドが終了しても動作する。<BR>
<BR>
Android では onDestroy が呼ばれても即プロセスは終了しないので、<BR>
指定がデーモンスレッド動作だとしてもタイマーは止まらない。<BR>
<BR>
スレッドタイプに関わらず終了時にタイマーは止めた方が安全。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/05/29 activity 起動時に IME が出ないようにする</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
UI が画面に納まらないので ScrollView を使うように変更したら<BR>
起動時に EditText にフォーカスが当たって IME が表示されるようになった。<BR>
<BR>
画面位置も EditText まで勝手にスクロールしてしまうのですごく邪魔。<BR>
対策方法は無いのかとググってみると focusable と focusableInTouchMode を<BR>
制御する方法があるらしいがなんか面倒な実装に思える。<BR>
<BR>
別の方法が無いかと探してみるとやっぱりあるじゃない。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
getWindow().setSoftInputMode(LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);<BR>
</TD></TR>
</TABLE>
<BR>
注意点は setContentView の前に呼ぶ必要があるのと、LayoutParams は<BR>
WindowManager の LayoutParams を使うこと。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
import android.view.WindowManager.LayoutParams;<BR>
</TD></TR>
</TABLE>
<BR>
これで起動時に IME が表示されなくなるし、<BR>
EditText をタップすれば IME がちゃんと表示される。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/05/17 Android NDK r10e リリース</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android の「次期バージョンＭが出るよー」とアナウンスがあったので<BR>
NDK が更新されそうだなと思っていたらやっぱり更新されてた。<BR>
<BR>
主な変更点はこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
・Cortex-A53 のエラッタ修正。<BR>
・Clang 3.6 を追加。(デフォルト使用)<BR>
・Clang 3.4 削除。<BR>
・GCC 4.6 削除。<BR>
・ld.gold を使ったマルチスレッド対応。--threadsオプションで有効になる。<BR>
・GDB/gdbserver を 7.7 に更新。<BR>
・Mac OS の 32bit NDKパッケージを今回から削除。<BR>
・細かいバグ修正が多数。<BR>
</TD></TR>
</TABLE>
<BR>
Mac OS は 64bit 環境だけ対応することになったみたい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/05/05 SDカードの読み込み権限</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 4.4 以降では SDカードの読み込みにも権限が必要になった。<BR>
これによってSDカードのファイルを読み込む古いアプリは動作しなくなる。<BR>
<BR>
ただし、書き込み権限(WRITE_EXTERNAL_STORAGE)を設定しているアプリは<BR>
読み込み権限も同時に与えられるのでこの問題は発生しない。<BR>
<BR>
開発対象が古い Android でも SDカードを読み込む必要があるのであれば<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
READ_EXTERNAL_STORAGE<BR>
</TD></TR>
</TABLE>
を AndroidManifest.xml に記述しておく事をお勧めする。<BR>
<BR>
READ_EXTERNAL_STORAGE を設定したアプリを 4.4 未満の端末に入れても動作する。<BR>
権限の要求を確認すると読み込み権限の表示は出ない。<BR>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/04/27 android デバッグドライバ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android のドライバが無い場合は google 汎用ドライバの android_winusb.inf に<BR>
デバイスマネージャのプロパティからから確認できるハードウェアIDを<BR>
追記すれば使えるようになる事がある。<BR>
（特に中国製タブレット。）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
C:\＜Android SDK のパス＞\extras\google\usb_driver<BR>
</TD></TR>
</TABLE>
フォルダが存在しない場合は Android SDK Manager で<BR>
Google USB Driver をダウンロードする。<BR>
<BR>
メーカーから提供されているドライバを入れても認識しないケースは<BR>
ユーザープロファイル（ログイン名）のパスにある<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
c:\＜ユーザープロファイル＞\.android\adb_usb.ini<BR>
</TD></TR>
</TABLE>
にベンダーIDを書き加えると認識する場合がある。<BR>
このファイルの改行は LF(0x0a) なので CR-LF にしか対応していないエディタで<BR>
編集すると書き換えが有効にならない可能性があるので注意する。<BR>
<BR>
本来、adb_usb.ini は自動生成されるファイルなので直接書き換えるのは良くない。<BR>
addon に端末の情報を記述した manifest.ini を作成し、下記のコマンドを実行する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
c:\＜Android SDK のパス＞\tools\android.bat update adb<BR>
</TD></TR>
</TABLE>
これを実行しても adb_usb.ini が更新されない場合は<BR>
直接書き換えるしかない。<BR>
<BR>
後はサーバーを再起動して端末を認識しているか確認。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb kill-server<BR>
adb start-server<BR>
adb devices<BR>
</TD></TR>
</TABLE>
<BR>
これでデバイスIDが表示されて右に device と表示されれば完了。<BR>
<BR>
device 以外が表示された場合の対処法。<BR>
unauthorized （権限が無い？）→ 端末を抜き差ししてサーバー再起動。<BR>
offline （認識したけど使用不可）→ Android SDK が極端に古いなら最新に更新。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/04/16 文字列の余白</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android で文字列を扱うとサイズが想定したドット数よりも大きくなる事が多い。<BR>
<BR>
TextView で上下に余白が入らないようにする。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:bufferType="spannable"<BR>
android:includeFontPadding="false"<BR>
</TD></TR>
</TABLE>
<BR>
EditText と Button はデフォルトでパディングが入っているので<BR>
パディング0を試してから値を設定するといいかもしれない。<BR>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/03/10 CRT の errno はスレッドセーフ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
CRT の関数はエラー値をグローバル変数 errno に設定する。<BR>
コレってマルチスレッドでエラー値が正しく取れないケースがあるのでは？<BR>
と思って調べてみた。<BR>
<BR>
とりあえず古い VC のヘッダを見てみた。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#if     (defined(_MT) || defined(_DLL)) && !defined(_MAC)<BR>
_CRTIMP extern int * __cdecl _errno(void);<BR>
#define errno   (*_errno())<BR>
#else<BR>
_CRTIMP extern int errno;<BR>
#endif<BR>
</TD></TR>
</TABLE>
<BR>
プロジェクトの設定で CRT を「シングルスレッド」にしていると<BR>
errno はグローバルな int 型だが、設定が「マルチスレッド」や「DLL」だと<BR>
_errno() の戻り値のポインタ参照先を返すマクロになっている。<BR>
<BR>
このポインタの領域はスレッド毎に異なるスレッドローカルストレージを使っているので<BR>
複数スレッドで errno を書き変わる関数を実行しても各スレッドで正しい値が取れる。<BR>
<BR>
Linux の errno もスレッド毎に異なる領域が割り当てられるのでスレッドセーフらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/02/22 Android SDK の ADB コマンド</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
パッケージ：com.hoge.hallo<BR>
パス：c:\workspace\hallo.apk<BR>
<BR>
アプリのインストール（新規）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb install c:\workspace\hallo.apk<BR>
</TD></TR>
</TABLE>
<BR>
アプリの上書きインストール（インストール済み）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb install -r c:\workspace\hallo.apk<BR>
</TD></TR>
</TABLE>
<BR>
アプリのアンインストール<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb uninstall com.hoge.hallo<BR>
</TD></TR>
</TABLE>
<BR>
アプリのアンインストール（データ、ディレクトリ保持）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb shell pm uninstall -k com.hoge.hallo<BR>
</TD></TR>
</TABLE>
<BR>
インストールされたアプリの確認<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb shell pm list packages<BR>
</TD></TR>
</TABLE>
<BR>
アプリのプロセス停止（要ルート権限）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb shell kill プロセスＩＤ<BR>
</TD></TR>
</TABLE>
<BR>
アプリの起動<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb shell am start -n com.hoge.hallo<BR>
</TD></TR>
</TABLE>
<BR>
アプリの強制停止<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb shell am force-stop com.hoge.hallo<BR>
</TD></TR>
</TABLE>
<BR>
ファイルの送信<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb push 送りたいファイルのパス(PC) 受け取りパス(Android)<BR>
</TD></TR>
</TABLE>
<BR>
ファイルの受信<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb pull 取り出したいファイルのパス(Android) 受け取りパス(PC)<BR>
</TD></TR>
</TABLE>
<BR>
ログの受信（CTRL-Cで解除するまで常時更新される）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb logcat<BR>
</TD></TR>
</TABLE>
<BR>
ログの受信（バッファ済みのみ表示）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
adb logcat -d<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/02/01 NewGlobalRef と NewLocalRef</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NewLocalRef は JNI 関数の呼び出し中だけ有効な参照カウンタらしい。<BR>
これって DeleteLocalRef でカウンタを減少する意味があまり無いような。<BR>
<BR>
関数内で大量の参照カウンタが発生する場合は DeleteLocalRef を使用しないと<BR>
メモリが不足するかも知れないけど数回なら大丈夫なんじゃないかと思ってしまう。<BR>
<BR>
NewGlobalRef は名前からわかるように長期的な参照カウンタ増加になる。<BR>
JNI 側でグローバル変数にJAVAオブジェクトを保持する場合に必要。<BR>
<BR>
java でこんな感じのコードを書くなら JNI 側で参照カウンタを増加させないと<BR>
次の GC でクラスインスタンスが破棄される事になる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
setCallback( new CallbackSub() );<BR>
</TD></TR>
</TABLE>
<BR>
そんな時は NewGlobalRef を使用する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
jcls = (*env)->GetObjectClass( env,obj );<BR>
g_jcls = (jclass*) (*env)->NewGlobalRef( env,jcls );<BR>
</TD></TR>
</TABLE>
<BR>
Android 5.0 の ART でも大丈夫かな…<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/01/19 メインスレッド以外からの描画</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android ではメインスレッド以外からの描画は出来ない制限がある。<BR>
<BR>
一般的な回避策としてメインスレッドで生成した Handler に post する方法。<BR>
これであればメインスレッドで描画処理が実行できる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Handler mHandler;<BR>
mHandler = new Handler();	// UIスレッドで生成すること！<BR>
<BR>
// 別スレッドから post する。<BR>
mHandler.post( new runDrawClass() );<BR>
</TD></TR>
</TABLE>
<BR>
メインスレッドで Handler を生成するのが面倒な場合は<BR>
getMainLooper() でメインスレッドを指定して生成する方法もある。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
import android.os.Looper;<BR>
<BR>
handler = new Handler(Looper.getMainLooper());<BR>
</TD></TR>
</TABLE>
<BR>
他にも方法が無いのかと探してみると Activity#runOnUiThread があった。<BR>
Activity のインスタンスにアクセスできるクラスなら便利。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
void runOnUiThread(Runnable action)<BR>
</TD></TR>
</TABLE>
<BR>
単純に描画要求だけなら invalidate() ではなく postInvalidate() を使う。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/01/16 Android SurfaceView の VSync</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
SurfaceView のチラツキが気になったので調べて見た。<BR>
<BR>
Android 4.1(Jelly Bean) のバージョンアップの変更点で<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
・16msの垂直同期に合わせる<BR>
・トリプルバッファリング<BR>
</TD></TR>
</TABLE>
とあったので Android 4.0.x までは VSync に合わせる事はしていなかったようだ…。<BR>
<BR>
垂直同期は unlock のタイミングで合わせているらしい。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
canvas = holder.lockCanvas();<BR>
// 描画処理<BR>
holder.unlockCanvasAndPost( canvas ); // 同期待ち発生？<BR>
</TD></TR>
</TABLE>
<BR>
Android 4.1 以降では描画処理がギリギリだと処理落ちする可能性が高いかも。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/01/09 カスタムView のコンストラクタ Lint エラー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
古いプロジェクトを引っ張り出して apk を作成しようとしたら<BR>
コンストラクタでエラーが出た。<BR>
<BR>
どうやら必要な public のコンストラクタが無いと言われているらしい。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
This class should be public (com.testOpenGL.GLSView)<BR>
</TD></TR>
</TABLE>
<BR>
文法に問題は無く、古い開発環境だとこのエラーは発生しない。<BR>
<BR>
原因を調べると xml でカスタム View を貼り付けた場合に、<BR>
貼り付けた View のコンストラクタで Lint がエラーを出しているのを確認した。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
&lt;com.testOpenGL.GLSView<BR>
&nbsp;&nbsp;android:id="@+id/surfaceView1"<BR>
&nbsp;&nbsp;android:layout_width="fill_parent"<BR>
&nbsp;&nbsp;android:layout_height="fill_parent"<BR>
/&gt;
</TD></TR>
</TABLE>
<BR>
他のプロジェクトも GLSurfaceView を継承して作成したクラスを<BR>
xml に貼り付けるとエラーになっていた。<BR>
でもなぜか SurfaceView だと発生しない。はて？<BR>
<BR>
もっとも簡単な対処方法は Lint のエラーを発生しないように変更すること。<BR>
プロジェクトを右クリック → Properties を選択、<BR>
Android Lint Preferences の項目から「Instantiatable」を選択、<BR>
「Fatal」を「Warning」に変更する
<BR>
これで警告に変更される。<BR>
<BR>
<BR>
コード修正で直すなら GLSurfaceView を直接 xml に貼り付けて、<BR>
レンダラだけを登録する方法。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
&lt;android.opengl.GLSurfaceView<BR>
&nbsp;&nbsp;android:id="@+id/surfaceView1"<BR>
&nbsp;&nbsp;android:layout_width="fill_parent"<BR>
&nbsp;&nbsp;android:layout_height="fill_parent"<BR>
/&gt;
</TD></TR>
</TABLE>
<BR>
Activity はこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
_renderer = new EntryRenderer();<BR>
_surface = (GLSurfaceView) findViewById( R.id.surfaceView1 );<BR>
_surface.setRenderer( _renderer );<BR>
</TD></TR>
</TABLE>
<BR>
この方法だとタッチ処理を GLSurfaceView 継承クラスで行っていた場合に<BR>
Activity 側にタッチ処理を移動する必要があるので注意。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/01/05 Android SDK のレイアウト互換性２</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
レイアウトのＵＩパーツの id は重複しても構わない。<BR>
古い開発環境では同じファイル内で重複IDがあってもエラーにならない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>状態</TD>
<TD>古い開発環境</TD>
<TD>最新の開発環境</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ファイル内の重複ID</TD>
<TD>許可</TD>
<TD>エラー</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>異なるファイルでの重複ID</TD>
<TD>許可</TD>
<TD>許可</TD>
</TR>
</TABLE>
<BR>
重複IDは使い方を誤るとバグの原因となる可能性もあるが、<BR>
onCreate の setContentView で読み込むレイアウトを可変にしても<BR>
ID が全て同じであれば Java コードを変更する必要が無い。<BR>
<BR>
端末の解像度に合わせてレイアウトを複数持つケースでも役に立つ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2015/01/04 Android SDK のレイアウト互換性</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
古いプロジェクトを最新の環境でビルドするとエラーは出ないが<BR>
apk パッケージを作成しようとするとエラーで弾かれた。<BR>
<BR>
どうやらレイアウトの XML でエラーが出ている。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android id definitions *must* be of the form @+id/name<BR>
</TD></TR>
</TABLE>
<BR>
古い開発環境ではこのエラーは発生せず apk を作成できる。<BR>
<BR>
UIパーツの ID を id 以外に割り振るとエラーが出る。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:id="@+idsub/txtValue"<BR>
</TD></TR>
</TABLE>
<BR>
調べてみると google が id 以外に割り振れたのが SDK のバグと言ってる感じがする。<BR>
<BR>
解決策は開発環境を古いものに戻すか、全てのコードで id に修正する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
android:id="@+id/sub_txtValue"<BR>
</TD></TR>
</TABLE>
<BR>
これ、修正するとなると Java コードも修正だから面倒だよね。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/12/28 Android Studio 1.0 を試す。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android Studio に eclipse からプロジェクトをインポートしてみる。<BR>
コメント行やコードの日本語が文字化け。<BR>
<BR>
Android Studio の設定で使用する標準フォントを日本語対応のフォントに<BR>
変更しても効果なし。<BR>
<BR>
ソースコードの文字コードが ShiftJIS なのが怪しいので<BR>
文字コードを UTF-8 に変換してからインポートすると、問題は発生しなかった。<BR>
<BR>
ShiftJIS のまま扱うには Android Studio 起動時の初回メニューから<BR>
インポートの設定を ShiftJIS に変更してからインポートを行う。<BR>
<BR>
ビルドするとこんな感じでエラーが出る。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Error:(27, 8) 繧ｨ繝ｩ繝ｼ: 縺薙?ｮ譁?蟄励?ｯ縲√お繝ｳ繧ｳ繝ｼ繝?繧｣繝ｳ繧ｰUTF-8縺ｫ繝槭ャ繝励〒縺阪∪縺帙ｓ<BR>
</TD></TR>
</TABLE>
<BR>
さらに環境変数で Javaコンパイラが ShiftJIS でコンパイルするように変更する。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/12/10 Android NDK r10d がリリース。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 公式の新しい開発環境 Android Studio 1.0 がリリース。<BR>
さらに Android NDK r10d もリリースされてた。<BR>
<BR>
変更点はバグ修正がメインみたい。いろいろ修正されている。<BR>
後は gcc 4.6 がツールチェインから削除されたくらいか。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/12/01 LibFlac 1.3.1</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
LibFlac が Version 1.3.1 にアップデート。<BR>
主な変更点はこんな感じ。<BR>
<BR>
・デコードの量子化処理の改善、特に24bit時のx86。<BR>
・SSE、AVXを使った高速なエンコード。<BR>
・新しいエンコード処理の追加、それのプリセット追加。<BR>
・デコード機能の脆弱性を修正。<BR>
<BR>
stream_decoder.c にはスタックベースのバッファオーバーフローの脆弱性が存在し、<BR>
Version 1.3.1 未満の全バージョンにこの問題があるとのこと。<BR>
<BR>
なお、LibFlac 1.3.0 で 2GB 超えに対応した時に古いコンパイラへの対応が<BR>
無くなっているので古いソフトのアップデートには新しい開発環境が必要になるかも。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/10/22 Android NDK r10c</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
最近、Android 5 の正式発表があったので思った通りアップデートされてた。<BR>
<BR>
前回 r10b までは 32bit と 64bit で異なっていたパッケージが ndk r10c では<BR>
１つに統合されて配布形式が 7zip の自己解凍形式に変更された。<BR>
（圧縮率を高くする為に 7zip にしたけどメジャーじゃないから自己解凍形式？）<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>今回のパッケージ名</TD>
<TD>ndk r10b の時のパッケージ名 </TD>
</TR>
<TR BGCOLOR="#008888">
<TD ROWSPAN="2">android-ndk-r10c-windows-x86.exe</TD>
<TD>android-ndk32-r10-windows-x86.zip</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk64-r10-windows-x86.zip</TD>
</TR>
<TR BGCOLOR="#008888">
<TD ROWSPAN="2">android-ndk-r10c-windows-x86_64.exe</TD>
<TD>android-ndk32-r10-windows-x86_64.zip</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk64-r10-windows-x86_64.zip</TD>
</TR>
</TABLE>
<BR>
ndk r10 32bit の解凍後は約４万ファイルの 1.5GB だったのが<BR>
今回は 64bit が統合されて約５万ファイルの 3.4GB まで増えている。<BR>
<BR>
主な変更はこんな感じ。<BR>
・32bit , 64bit のヘッダ、ライブラリの統合。<BR>
・platforms に android-21 を追加。<BR>
・コンパイラの変更<BR>
　・32bit でも 64bit と同じ gcc 4.9 を追加。<BR>
　・gcc 4.6 は今後削除予定。<BR>
　・clang 3.5 を追加。(clang のデフォルトも 3.5 に変更)<BR>
　・clang 3.3 を削除。<BR>
・Android 5.0 の ART Debug に対応。<BR>
・バグ修正。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/10/20 Android 5.0 の互換性</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android L は正式に Android 5.0 となったみたい。<BR>
そして Android 5.0 は 64bit で動作するけど既存のアプリは動くのか？<BR>
<BR>
JAVA でアプリを作ってるから「32bit,64bit なんて関係ないだろ」と<BR>
思うかもしれないけど、実は JAVA コードを解析実行する部分に変更が入っている。<BR>
<BR>
Android の JAVA コード処理には Dalvik が使われてきたが 5.0 ではこれが<BR>
Android RunTime (ART) に変更されていて 100% の互換性があるかは不明。<BR>
<BR>
Dalvik は実行時によく使われる部分をネイティブコードに変換して実行する。<BR>
ネイティブコードは保存されないので実行時に変換処理が毎回発生する。<BR>
<BR>
ART ではアプリのインストール時に全てをネイティブコードに変換して<BR>
結果をストレージに保存して置くので初回のみ変換処理が発生する。<BR>
<BR>
ART のメリットはアプリ全体を最適化できるのと実行時の変換負荷が無いこと。<BR>
また、GC の方式が改良されて効率が良くなっているらしい。<BR>
デメリットはインストール時の時間増加と容量増大。<BR>
<BR>
実は Android 4.4 も開発者向けにお試し実装されていて<BR>
開発者オプション→「ランタイムを変更」→「ARTを使用する」<BR>
で ART を使用したアプリの実行が試せるらしい。<BR>
ART では JNI を使ったアプリが動かないとのウワサも。<BR>
<BR>
ART に変更すると端末が再起動され、インストール済みアプリの<BR>
ネイティブコード変換が行われて実行可能になる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/09/27 「ＧＰＵレンダリング使用」の制限</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
開発者向けオプションの「ＧＰＵレンダリング使用」をＯＮにすると<BR>
画像処理が速くなる可能性がある。<BR>
ただし、一部のアプリでは正常に描画が行われない可能性があるので注意する。<BR>
<BR>
この問題は拡大縮小をＧＰＵのテクスチャ機能を使って行うので<BR>
画像サイズがハードウェアの限界サイズを超えると問題が発生する。<BR>
<BR>
テクスチャの限界サイズを超えるとログに出力される。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
W/OpenGLRenderer(4048): Bitmap too large to be uploaded into a texture (1800x2400, max=2048x2048)<BR>
</TD></TR>
</TABLE>
<BR>
Android OS は最低でも 2048x2048 のテクスチャを扱えることをハードウェアの<BR>
必須条件にしているので 2048x2048 まではどの端末でも問題ない。<BR>
<BR>
「ＧＰＵレンダリング使用」がＯＦＦの場合はＣＰＵで全て処理するので<BR>
画像サイズに制限は無く、 2048x2048 以上も扱える。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/09/16 Android NDK r10b</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r10 がアップデートされてた。<BR>
変更内容は主に Android L (64bit) の問題修正。<BR>
従来の 32bit 環境向けはほとんど更新が無いように思える。<BR>
<BR>
遅い気もするけど今回注意事項としてパッケージに512MBの制限があるから<BR>
Android L 用のヘッダや gcc4.9 は ndk64 にしか入れてないよとあった。<BR>
<BR>
「ファイルが入ってない」と r10 リリースの時に問い合わせが多かったのかも。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/09/15 gcc の浮動少数からのキャスト</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
マイナスの浮動少数値を符号なし整数にキャストすると VC と gcc で結果が異なる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
double a = -1.0;<BR>
unsigned int b = (unsigned int)a;<BR>
<BR>
printf( "b = %d",b );<BR>
</TD></TR>
</TABLE>
<BR>
VC だと結果は 0xffffffff (-1) になるが gcc だと 0 になる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/09/06 OpenSL の再生終了通知</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
OpenSL で BufferQueue を使わずに直接ファイル (正確には URI や FileDescriptor) を<BR>
指定した再生で再生終了通知を得るには SLPlayItf インターフェースを使用する。<BR>
<BR>
通知時に呼び出されるコールバック関数を用意して登録する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
static void PlayCallback(SLPlayItf caller, void *pContext, SLuint32 event)<BR>
{<BR>
&ensp;switch( event )<BR>
&ensp;{<BR>
&ensp;&ensp;case SL_PLAYEVENT_HEADATEND:<BR>
&ensp;&ensp;LOGI( "PlayerObject->Callback(SL_PLAYEVENT_HEADATEND)\n" );<BR>
&ensp;&ensp;break;<BR>
&ensp;}<BR>
}<BR>
<BR>
void reg_end_callback()<BR>
{<BR>
&ensp;SLresult result;<BR>
&ensp;// register callback on the PlayerObject<BR>
&ensp;result = (*fdPlayerPlay)->RegisterCallback( fdPlayerPlay,PlayCallback,NULL );<BR>
&ensp;result = (*fdPlayerPlay)->SetCallbackEventsMask( fdPlayerPlay,SL_PLAYEVENT_HEADATEND );<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
SetCallbackEventsMask で通知して欲しい種別を指定する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
SL_PLAYEVENT_HEADATEND<BR>
SL_PLAYEVENT_HEADATMARKER<BR>
SL_PLAYEVENT_HEADATNEWPOS<BR>
SL_PLAYEVENT_HEADMOVING<BR>
SL_PLAYEVENT_HEADSTALLED<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/09/02 OpenSL の繰り返し再生</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
OpenSL で BufferQueue を使わずに直接ファイル (正確には URI や FileDescriptor) を<BR>
指定して繰り返し再生するケースでは SLSeekItf インターフェースを使用する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
(*fdPlayerSeek)->SetLoop( fdPlayerSeek,SL_BOOLEAN_TRUE,0,SL_TIME_UNKNOWN );<BR>
</TD></TR>
</TABLE>
<BR>
Ｃ＋＋ではなくＣ言語なので第１引数は self を指定する。<BR>
次の引数から「有効無効、ループ開始位置(ミリ秒)、ループ終了位置(ミリ秒)」となる。<BR>
終了位置を最後にする場合は SL_TIME_UNKNOWN を指定する。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/08/29 OpenSL の圧縮ファイル再生開始の硬直</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
OpenSL で BufferQueue を使わずに直接ファイル (正確には URI や FileDescriptor) を<BR>
指定して OggVorbis を再生開始すると一瞬硬直してしまう。<BR>
(サイズ-１秒,圧縮時11KB,解凍時88KB-44KHz,16bit,mono)<BR>
<BR>
ＢＧＭであれば画面が切り替わった時に再生するのでそれほど問題にならないが<BR>
効果音だと再生タイミングが不定な場合が多く都合が悪い。<BR>
<BR>
FileDescriptor を指定してインターフェースを生成した時なら対処もできるが…<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
(*engineEngine)->CreateAudioPlayer( ... );<BR>
</TD></TR>
</TABLE>
<BR>
硬直するのは再生開始のタイミング…どうしましょ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
(*fdPlayerPlay)->SetPlayState( fdPlayerPlay,SL_PLAYSTATE_PLAYING );<BR>
</TD></TR>
</TABLE>
<BR>
自前で LibOgg,LibVorbis を利用してバッファキュー再生するしかないか。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/08/27 OpenSL で複数同時再生</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
移植で DirectSound や DirectAudio のコードを置き換える場合とか。<BR>
<BR>
OpenSL を使って BGM と複数の効果音を同時に再生するには<BR>
SLObjectItf (AudioPlayer) を必要な分だけ複数生成すれば可能になる。<BR>
<BR>
生成可能な個数は端末依存と思われる。16個くらいなら古い端末でも平気かも。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#define AUDIO_IF_NUM 10<BR>
static SLObjectItf g_engineObject;<BR>
static SLEngineItf g_engineEngine;<BR>
static SLObjectItf g_outputMixObject;<BR>
static SLObjectItf bqPlayerObject[AUDIO_IF_NUM];<BR>
static SLPlayItf bqPlayerPlay[AUDIO_IF_NUM];<BR>
static SLEffectSendItf bqPlayerEffectSend[AUDIO_IF_NUM];	//必須では無い<BR>
static SLMuteSoloItf bqPlayerMuteSolo[AUDIO_IF_NUM];		//必須では無い<BR>
static SLVolumeItf bqPlayerVolume[AUDIO_IF_NUM];			//必須では無い<BR>
static SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue[AUDIO_IF_NUM];<BR>
</TD></TR>
</TABLE>
<BR>
PCM の再生フォーマットが全て同じなら複数必要な IF を for 文で回して生成する。<BR>
バッファーキューのコールバックはどれから呼ばれても動作するようにするか、<BR>
個別にコールバック関数を用意するようにする。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/08/15 Android NDK r10 のパッケージ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r10 から配布パッケージに Android L 用が追加された。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>パッケージ名</TD>
<TD>開発環境</TD>
<TD>開発ターゲット</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk32-r10-windows-x86.zip</TD>
<TD>32bit の Windows 系 OS</TD>
<TD>Android ～4.4</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk32-r10-windows-x86_64.zip</TD>
<TD>64bit の Windows 系 OS</TD>
<TD>Android ～4.4</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk64-r10-windows-x86.zip</TD>
<TD>32bit の Windows 系 OS</TD>
<TD>Android L (64bit)</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>android-ndk64-r10-windows-x86_64.zip</TD>
<TD>64bit の Windows 系 OS</TD>
<TD>Android L (64bit)</TD>
</TR>
</TABLE>
<BR>
NDK r10 の変更内容は ndk32 と ndk64 の２つを合わせて記載しているので<BR>
新規追加したヘッダやライブラリが ndk32 に無くて ndk64 には入っている場合がある。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/07/22 Android NDK r10 で clang のバージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
clang 3.4 でgccコンパイラ用のバージョンマクロを使うと…<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
sprintf( buf,"gcc ver %d.%d.%d\n",<BR>
 __GNUC__,<BR>
 __GNUC_MINOR__,<BR>
 __GNUC_PATCHLEVEL__ );<BR>
LOGI( "%s",buf );<BR>
</TD></TR>
</TABLE>
<BR>
結果はなぜか古いバージョンが設定されている。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
gcc ver 4.2.1<BR>
</TD></TR>
</TABLE>
<BR>
調べてみると clang 専用にバージョンマクロがあった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="200">記述</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__VERSION__</TD>
<TD>gcc なら "4.8"<BR>clang 3.4 なら "4.2.1 Compatible Clang 3.4"</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang__</TD>
<TD>gcc なら定義されないのでこれで判別できる。<BR>clang なら値が 1 で定義される</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang_major__</TD>
<TD>clang 3.4 なら値が 3 で定義される</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang_minor__</TD>
<TD>clang 3.4 なら値が 4 で定義される</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang_patchlevel__</TD>
<TD>clang 3.4 なら値が 0 で定義される</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang_version__</TD>
<TD>clang 3.4 なら値が "3.4"</TD>
</TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/07/21 Android NDK r10 で単体実行ファイル</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK r10 でコンパイラを clang にして単体実行ファイルをビルドすると実行時に<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
[1]   Segmentation fault      /data/local/ndkexe<BR>
</TD></TR>
</TABLE>
<BR>
とセグメント例外で落ちるので調べてみた。<BR>
<BR>
とりあえずコンパイラを gcc にすると発生しない。<BR>
clang のデフォルトは 3.4 なので clang3.3 を指定してみると問題ない。<BR>
単体実行ファイルを clang3.4 で作るとダメらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/07/19 Android NDK r10 のコンパイラ選択</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK で使用するコンパイラは Application.mk で指定可能だけど何が指定できるか<BR>
わからない時は NDK を展開したフォルダの toolchains を参照すればわかる。<BR>
<BR>
NDK r10 の toolchains に存在するフォルダ一覧。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
arm-linux-androideabi-4.6<BR>
arm-linux-androideabi-4.8<BR>
arm-linux-androideabi-clang3.3<BR>
arm-linux-androideabi-clang3.4<BR>
llvm-3.3<BR>
llvm-3.4<BR>
mipsel-linux-android-4.6<BR>
mipsel-linux-android-4.8<BR>
mipsel-linux-android-clang3.3<BR>
mipsel-linux-android-clang3.4<BR>
renderscript<BR>
x86-4.6<BR>
x86-4.8<BR>
x86-clang3.3<BR>
x86-clang3.4<BR>
</TD></TR>
</TABLE>
<BR>
フォルダ名の最後の -(ハイフン) より後ろの名前を Application.mk の<BR>
NDK_TOOLCHAIN_VERSION に指定するとそのコンパイラが使用される。<BR>
<BR>
何も指定しない場合は NDK のデフォルト値が使われる。<BR>
NDK r10 では 4.8 (gcc 4.8.3) が使われる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
NDK_TOOLCHAIN_VERSION=4.6<BR>
</TD></TR>
</TABLE>
<BR>
とした場合は gcc 4.6 が使われる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
NDK_TOOLCHAIN_VERSION=clang3.3<BR>
</TD></TR>
</TABLE>
<BR>
とした場合は clang3.3 が使われる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
NDK_TOOLCHAIN_VERSION=clang<BR>
</TD></TR>
</TABLE>
<BR>
この場合は NDK r10 でデフォルトに設定されている clang3.4 が使われる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/07/17 Android NDK r10</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
先日発表された Android L に対応。<BR>
変更内容を見ると64ビットアプリにも対応しているようなので<BR>
Android L は 64bit で動作するのかも。<BR>
<BR>
仕様が確定していないのか API Level の表記が API Level L 。<BR>
ちなみに Android 4.4 (KitKat) は Level 19 。<BR>
<BR>
Android L (64bit) 向けのコンパイラは gcc 4.9 がデフォルト。<BR>
従来の API Level 19 までは gcc 4.8 がデフォルトになり、<BR>
clang を選択した場合のデフォルトは 3.4 になった。<BR>
<BR>
ドキュメントには platforms/Android-L/ を追加したって記述があるけど<BR>
android-ndk32-r10-windows-x86.zip には入ってない…リリース漏れ？<BR>
<BR>
サンプルに Level 19 用の native-codec が追加されてた。<BR>
これは MediaCodec の NDK 版かも。<BR>
<BR>
修正内容を確認すると wchar_t に修正があった。<BR>
オプションで wchar_t を２バイトにできるっぽい。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
○Fixed WCHAR_MIN and WCHAR_MAX so that they they take appropriate<BR>
 signs according to the architecture they're running on:<BR>
・X86/MIPS: signed.<BR>
・ARM: unsigned.<BR>
・To force X86/MIPS to default to unsigned, use -D__WCHAR_UNSIGNED__.<BR>
・To force wchar_t to be 16 bits, use -fshort-wchar.<BR>
</TD></TR>
</TABLE>
<BR>
NDK r9d であった LibVorbis の hardfp 動作不良も起きなくなっている。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/06/02 Android NDK の wchar_t 宣言</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows 用のコード移植で wchar_t を使っている場合は注意が必要。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOGI( "sizeof(wchar_t) == [%d]\n",sizeof(wchar_t) );<BR>
</TD></TR>
</TABLE>
<BR>
sizeof の結果は<FONT COLOR="#FF0000">４</FONT>になる。<BR>
<BR>
<FONT COLOR="#FF0000">Windows だと wchar_t は２バイト</FONT>
なので wcscpy を使ったコードを無理やり<BR>
ビルドすると文字列終端を発見できずにアクセス例外が発生する可能性がある。<BR>
<BR>
<FONT COLOR="#FF0000">追記 2014/07/17<BR>
NDK r10 以降では -fshort-wchar で２バイトに変更できる。<BR></FONT>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/05/21 gcc のプロトタイプ宣言有無</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
プロトタイプ宣言の警告の相違。<BR>
通常の状態でプロトタイプ宣言が無い場合に出る警告。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
warning: implicit declaration of function 'printf'<BR>
</TD>
</TR>
</TABLE>
<BR>
gcc の C99 規格オプションでコンパイルすると<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
gcc -std=c99<BR>
</TD></TR>
</TABLE>
<BR>
警告が次のように変わる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
warning: implicit declaration of function 'printf' is invalid in C99<BR>
</TD></TR>
</TABLE>
<BR>
Android NDK でビルドすると後者の警告が出る。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/05/12 Android NDK で単体実行ファイル作成。</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
実は共有ライブラリだけでなく単体実行ファイルも動作する。<BR>
<BR>
Android.mk はこんな感じ。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_PATH := $(call my-dir)<BR>
include $(CLEAR_VARS)<BR>
LOCAL_MODULE    := ndkexe<BR>
LOCAL_SRC_FILES := ndkexe.c<BR>
LOCAL_LDLIBS    := -llog<BR>
include $(<FONT COLOR="#ff0000">BUILD_EXECUTABLE</FONT>)<BR>
</TD></TR>
</TABLE>
<BR>
ソース<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#include &lt;stdio.h&gt;<BR>
#include &lt;android/log.h&gt;<BR>
int main()<BR>
{<BR>
&ensp;printf("hello.\n");<BR>
&ensp;__android_log_print(ANDROID_LOG_INFO,"tag","hello.\n");<BR>
&ensp;return 0;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
printf は実行したコマンドプロントに出力される。<BR>
__android_log_print は eclipse の logcat に出力される。<BR>
<BR>
転送と実行を行うバッチファイル<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
@echo off<BR>
path %Path%;C:\android\platform-tools<BR>
adb -d push C:\workspace\ndk-exe\libs\armeabi/ndkexe /data/local<BR>
adb -d shell chmod 755 /data/local/ndkexe<BR>
adb -d shell /data/local/ndkexe<BR>
pause<BR>
</TD></TR>
</TABLE>
<BR>
実機のフォルダは /data/ 下以外では権限の問題で実行できない。<BR>
（/data/local/ 等のサブフォルダでも実行可能。）<BR>
<BR>
SDCard をマウントしたフォルダには push で転送できても<BR>
chmod で権限による失敗が発生してエラーが表示される。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Operation not permitted<BR>
</TD></TR>
</TABLE>
<BR>
chmod が成功すれば作成したファイルを実行する事が出来る。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/05/03 clang の ShiftJIS ダメ文字</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
clang で ShiftJIS のダメ文字をコンパイルすると正常に動作しないっぽい。<BR>
<BR>
※ "能" のコードは { 0x94,0x5c } で 0x5c を含むのでダメ文字。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
char *p = "能力";<BR>
printf( "%s\n",p );<BR>
</TD></TR>
</TABLE>
<BR>
上記のコードをビルドしてバイナリのデータ部分をダンプで確認すると、<BR>
{0x94,0x5c,0x97,0xcd,0x00}; となるべきが<BR>
{0x94,0x97,0xcd,0x00}; と 0x5c が抜けた状態になってしまう。<BR>
<BR>
これだと表示がおかしくなるのでコードを書き換える。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
static unsigned char __damemoji[] = {0x94,0x5c,0x97,0xcd,0x00};<BR>
char *p = (char*)__damemoji;<BR>
printf( "%s\n",p );<BR>
</TD></TR>
</TABLE>
<BR>
ただしコメント行の途中にダメ文字を記述するのは問題ないみたい。怖いけど。<BR>
文字コードを UTF-8 にすればこんな問題は起きないんだけど…<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/05/02 clang の ShiftJIS コンパイル</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
clang で文字コードが ShiftJIS のソースをコンパイルすると<BR>
文字コードに問題があると警告が出る。(gcc だと出ない。)<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
printf("ハローワールド。\n");<BR>
</TD></TR>
</TABLE>
<BR>
こんなコードを記述すると警告が。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
warning: illegal character encoding in string literal<BR>
 [-Winvalid-source-encoding]<BR>
printf("<83>n<83><8D><81>[<83><8F><81>[<83><8B><83>h<81>B\n");<BR>
</TD></TR>
</TABLE>
<BR>
ソースコードを UTF-8 で保存するのが一番なんだけど<BR>
Windows 環境だといろいろと面倒な事が多くてなぁ。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/05/01 Android NDK r9d clang の警告</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
gcc 4.8 でコードをビルドすると警告が出ないのに<BR>
clang に切り替えてビルドすると大量に警告が発生した。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
type_defs.h:100:13: warning:warning:<BR>
redefinition of typedef 'int32_t' is a C11 feature [-Wtypedef-redefinition]<BR>
typedef int int32_t;<BR>
types_def.h:55:13:note: previous definition is here<BR>
typedef int int32_t;<BR>
</TD></TR>
</TABLE>
<BR>
int32_t が C11 では予約キーワードになっていて再定義された？かと思ったが、<BR>
よく見ると単なる typedef の再定義警告だった。<BR>
原因は似たような名称の２つのファイルで次のように記述していたこと。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#ifndef int32_t<BR>
typedef int int32_t;<BR>
#endif<BR>
</TD></TR>
</TABLE>
<BR>
確かに再定義になってしまうので #define を使うように修正。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#ifndef int32_t<BR>
#define int32_t int<BR>
#endif<BR>
</TD></TR>
</TABLE>
<BR>
あまり良いコードとは思えないが警告は出なくなった。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/19 Android NDK r9d の hardfp</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r9b で限定的サポートのような扱いだった ARM の<BR>
-mhard-float が NDK r9d では正式サポートされたようだ。<BR>
これは関数の引数が浮動小数だった場合に直接FPレジスタに値を入れて<BR>
受け渡すようにする高速化オプション。<BR>
<BR>
NDK 側のライブラリは softfp のままらしいので自分でコンパイルするソースに<BR>
浮動小数を使った関数呼び出しが多い場合に効果がある。<BR>
<BR>
NDK r9b では clang 非対応だったが NDK r9d では特に記述が無く、<BR>
 clang でも使えるようなので試してみた。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
APP_ABI=armeabi-v7a-hard<BR>
</TD></TR>
</TABLE>
<BR>
あれ… LibVorbis の実行結果がおかしくなった。<BR>
<BR>
最適化オプションを弱めに設定しても変化なし。<BR>
hardfp を切ると正常な実行結果に戻った…。<BR>
<BR>
<FONT COLOR="#FF0000">追記 2014/07/17<BR>
NDK r10 以降ではこの問題が改善された。<BR></FONT>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/18 Android 4.x のメディア機能</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android 4.x (API Level 14) 以降では NDK で MP4 のデコードが可能みたいな話が<BR>
あったので調べてみた。<BR>
<BR>
NDK では OMXAL/OpenMAXAL.h が該当する。<BR>
OpenMAX は 2006 年に Khronos で策定された規格で結構昔からあったようだ。<BR>
<BR>
OpenMAX は３つのソフトウェア層で構成されていて上からこんな感じ。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
OpenMAX AL (Application Layer) high-level playback and recording<BR>
OpenMAX IL (Integration Layer) media conponent<BR>
OpenMAX DL (Development Layer) media primitives and concerrency constructs<BR>
</TD></TR>
</TABLE>
<BR>
各層の機能は次のような感じらしい。<BR>
<BR>
AL は DirectShow ような再生、停止といった高レベルな API。<BR>
IL は DirectShow Filter (transform) のようなコーデック API。<BR>
DL は動画や音声のデコード、エンコードを行うドライバ API。<BR>
<BR>
NDK から使える機能は AL だけで動画の場合は<BR>
JAVA 側から Surface を受け取り NativeWindow に関連付けする。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
// for native window JNI<BR>
#include &lt;android/native_window_jni.h&gt;<BR>
ANativeWindow* ANativeWindow_fromSurface(JNIEnv* env, jobject surface);<BR>
</TD></TR>
</TABLE>
<BR>
後はファイルを読み込んでバッファキューに詰める OpenSL のような<BR>
実装をすれば動画再生が可能になる。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/12 Android NDK r9d と ndk-build</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r9 のドキュメントに記載がある ndk-build のオプション一覧。<BR>
オプションは組み合わせて使うことも可能。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="200">記述</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>clean </TD>
<TD>生成物の除去</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>V=1</TD>
<TD>gcc へ渡すコマンドを表示する。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>-B</TD>
<TD>強制的にリビルドする。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NDK_LOG=1</TD>
<TD>NDK 内部のログを表示する。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NDK_DEBUG=1</TD>
<TD>デバッグモードでビルドする。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NDK_DEBUG=0</TD>
<TD>リリースモードでビルドする。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NDK_HOST_32BIT=1</TD>
<TD>64bit 環境でも 32bit の toolchain を使う。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NDK_APPLICATION_MK=[file]</TD>
<TD>application.mk の代わりに[file]を使用してビルドする。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>-C [project]</TD>
<TD>[project] で指定されたパスをビルドする。</TD>
</TR>
</TABLE>
<BR>
デフォルトはこんな感じだと思われる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
ndk-build V=0 NDK_LOG=0 NDK_DEBUG=1<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/08 Android NDK r9d のマルチスレッドビルド</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows 以外の環境だと動作していたっぽいマルチスレッドビルド。<BR>
NDK ドキュメントには記載が無い。<BR>
<BR>
Android NDK r8b でマルチスレッドビルドを試した時は Error 3 が表示されて<BR>
 MAKE コマンドが失敗していたのが Android NDK r9d では正常動作している。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
ndk-build -j 4<BR>
</TD></TR>
</TABLE>
<BR>
もしくは<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
ndk-build --jobs=4<BR>
</TD></TR>
</TABLE>
<BR>
CPU のコア数と同じ数にすれば高速化されるのを確認。<BR>
ただし、ハイパースレッティングな CPU ではスレッド数に合わせても<BR>
速くなるかは不明。AMD の Bulldozer 系なら速くなるかも。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/03 Android NDK r9d と C++ ライブラリ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android NDK r9d でサポートする C++ ライブラリ。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>library</TD>
<TD>Exceptions</TD>
<TD>RTTI</TD>
<TD>STL</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>system</TD>
<TD>×</TD>
<TD>×</TD>
<TD>×</TD>
<TD>default minimal system C++ runtime library</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>gabi++_static<BR>gabi++_shared</TD>
<TD>×</TD>
<TD>○</TD>
<TD>×</TD>
<TD>GAbi++ runtime as a library</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>stlport_static<BR>stlport_shared</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>STLport runtime as a library</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>gnustl_static<BR>gnustl_shared</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>GNU Standard C++ Library<BR>(a.k.a. libstdc++-v3)<BR>GNU STL as a library</TD>
</TR>
</TABLE>
<BR>
ライブラリのソースやヘッダは以下のパスで確認出来る。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
（NDKをインストールしたパス）\sources\cxx-stl\system\include<BR>
（NDKをインストールしたパス）\sources\cxx-stl\stlport\stlport<BR>
（NDKをインストールしたパス）\sources\cxx-stl\gnu-libstdc++\4.8\include<BR>
（NDKをインストールしたパス）\sources\cxx-stl\gabi++\include<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/04/02 Android NDK r9d で STL</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
標準状態では #include &lt;string&gt; のビルドが通らなかった。<BR>
当然 #include &lt;vector&gt; もビルドが通らない。<BR>
.h 無しヘッダ非対応かと思えば #include &lt;cstring&gt; は通る…。はて？<BR>
<BR>
C++ ヘッダや STL が使えないか NDK のドキュメントを見てみると、<BR>
NDK デフォルトライブラリの system は必要最低限の最小構成で<BR>
C++ の機能として Exception, RTTI, STL は使えないらしい。<BR>
<BR>
ただし、STL が使える C++ ライブラリを Application.mk で<BR>
指定すれば使えそうなので試してみた。<BR>
(注意事項で Android.mk に書いても意味は無いとあった。)<BR>
とりあえず GPL 系は避けたいので STLport を使う事にした。<BR>
<BR>
Application.mk に APP_STL を記述する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
APP_STL := stlport_shared<BR>
</TD></TR>
</TABLE>
<BR>
今度は例外処理でビルドエラーが出たので Android.mk に<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
LOCAL_CPP_FEATURES += exceptions
</TD></TR>
</TABLE>
<BR>
を記述してビルドするとエラーが出なくなった。<BR>
<BR>

これでビルドは通ったけど、<BR>
libs\armeabi-v7a\libstlport_shared.so (374,076byte)<BR>
がコピーされていた。<BR>
<BR>
実機の Android OS 側で保持された共有ライブラリじゃなくて<BR>
 apk に含めて使うって事なのか…。共有ライブラリの意味が無いような…。<BR>
でも、この方法なら Android バージョンに依存しないメリットがあるか。<BR>
<BR>
次に Application.mk をスタティックリンクに書き換えてみた。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
APP_STL := stlport_static
</TD></TR>
</TABLE>
<BR>
スタティックリンクだと libstlport_shared.so はコピーされず、<BR>
本体が 20kbyte 程度増えるだけで済んだのでスタティックリンクにする事にした。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/03/27 NDK r9 NativeActivity 書き換え</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NativeActivity でアプリを作成するとエントリーポイントは<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
（NDKをインストールしたパス）\sources\android\native_app_glue\<BR>
android_native_app_glue.c<BR>
<BR>
void ANativeActivity_onCreate()<BR>
</TD></TR>
</TABLE>
<BR>
になる。<BR>
<BR>
このままだと困るので JNIEXPORT を付け加える。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
422: JNIEXPORT void ANativeActivity_onCreate(ANativeActivity* activity,
</TD></TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/02/14 gcc の警告抑制</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
基本的にはコンパイルした時に警告が出ないソースコードがベストだけど<BR>
そうもいかない時もある。<BR>
<BR>
gcc でも pragma で ON/OFF の切り替えが可能。<BR>
VC 等、他のコンパイラとの文法に互換性は無い。<BR>
<BR>
例えば、使用していない変数の警告は -Wunused なので<BR>
<BR>
変数の警告を無効にする場合<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#pragma GCC diagnostic ignored "-Wunused"<BR>
</TD></TR>
</TABLE>
<BR>
変数の警告を有効にする場合<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#pragma GCC diagnostic warning "-Wunused"<BR>
</TD></TR>
</TABLE>
<BR>
とソースコードの先頭に記述すれば、警告設定が変更される。<BR>
<BR>
また、ソースコードの一部のみに適用することも可能。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#pragma GCC diagnostic push // 現在の警告設定を保存する<BR>
#pragma GCC diagnostic ignored "-Wunused"<BR>
void test1()<BR>
{<BR>
&ensp;int a; // 警告が出ない<BR>
}<BR>
#pragma GCC diagnostic pop // 警告設定を復帰する<BR>
<BR>
void test2()<BR>
{<BR>
&ensp;int b; // 警告が出る<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2014/01/07 Win64 で追加された型</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Win64 で追加されたサイズ指定の型。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="200">型</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>DWORD32</TD>
<TD>32 ビット符号なし整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>DWORD64</TD>
<TD>64 ビット符号なし整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>INT32</TD>
<TD>32 ビット符号付き整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>INT64</TD>
<TD>64 ビット符号付き整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>LONG32</TD>
<TD>32 ビット符号付き整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>LONG64</TD>
<TD>64 ビット符号付き整数</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>UINT32</TD>
<TD>符号なし INT32</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>UINT64</TD>
<TD>符号なし INT64</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ULONG32</TD>
<TD>符号なし LONG32</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ULONG64</TD>
<TD>符号なし LONG64</TD>
</TR>
</TABLE>
<BR>
Win64 で追加されたポインタに関係する型<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#008888">
<TD>DWORD_PTR</TD>
<TD>ポインタ精度の符号なし LONG 型</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>HALF_PTR</TD>
<TD>ポインタの半分のサイズで、1 つのポインタと<BR>
2つの小さな領域が含まれる構造体で使用します</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>INT_PTR</TD>
<TD>ポインタ精度の符号付き integer 型</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>LONG_PTR</TD>
<TD>ポインタ精度の符号付き LONG 型</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>SIZE_T</TD>
<TD>ポインタが参照できる最大バイト数 <BR>
(ポインタのすべての範囲に対応する必要がある<BR>カウントで使用します)</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>SSIZE_T</TD>
<TD>符号付き SIZE_T</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>UHALF_PTR</TD>
<TD>符号なし HALF_PTR</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>UINT_PTR</TD>
<TD>符号なし INT_PTR</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ULONG_PTR</TD>
<TD>符号なし LONG_PTR</TD>
</TR>
</TABLE>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/22 OS と IE のバージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows のサポートする Internet Explorer のバージョン。<BR>

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">バージョン</TD>
<TD>標準</TD>
<TD>最終</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8.1</TD>
<TD>11.0</TD>
<TD>-</TD>
<TD>最新の IE 11.0 が使用可能。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8</TD>
<TD>10.0</TD>
<TD>10.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 7</TD>
<TD>8.0</TD>
<TD>-</TD>
<TD>最新の IE 11.0 が使用可能。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows Vista</TD>
<TD>7.0</TD>
<TD>9.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows XP</TD>
<TD>6.0</TD>
<TD>8.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 2000</TD>
<TD>5.0</TD>
<TD>6.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows NT4</TD>
<TD>無し</TD>
<TD>6.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows ME</TD>
<TD>5.5</TD>
<TD>6.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98SE</TD>
<TD>4.0</TD>
<TD>6.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98</TD>
<TD>4.0</TD>
<TD>6.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95 OSR2～</TD>
<TD>3.0</TD>
<TD>5.5</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95</TD>
<TD>無し</TD>
<TD>5.5</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/21 OS と MediaPlayer のバージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows のサポートする Media Player のバージョン。<BR>

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">バージョン</TD>
<TD>標準</TD>
<TD>最終</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8.1</TD>
<TD>12</TD>
<TD>-</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8</TD>
<TD>12</TD>
<TD>-</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 7</TD>
<TD>12</TD>
<TD>-</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows Vista</TD>
<TD>11</TD>
<TD>11</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows XP</TD>
<TD>XP(8相当)</TD>
<TD>11</TD>
<TD>11 は Service Pack2 以降が必要。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 2000</TD>
<TD>6</TD>
<TD>9</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows NT4</TD>
<TD>無し</TD>
<TD>6.4</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows ME</TD>
<TD>7</TD>
<TD>9</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98SE</TD>
<TD>4.1</TD>
<TD>9</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98</TD>
<TD>4.1</TD>
<TD>7.1</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95 OSR2～</TD>
<TD>4.0</TD>
<TD>6.4</TD>
<TD>7のサポートは無いがインストール可能。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95</TD>
<TD>4.0</TD>
<TD>6.4</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/20 OS と DirectX のバージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows のサポートする DirectX のバージョン。<BR>

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">バージョン</TD>
<TD>標準</TD>
<TD>最終</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8.1</TD>
<TD>11.2</TD>
<TD>-</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8</TD>
<TD>11.1</TD>
<TD>-</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 7</TD>
<TD>-</TD>
<TD>11.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows Vista</TD>
<TD>9.0Ex</TD>
<TD>11.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows XP</TD>
<TD>8.1</TD>
<TD>9.0c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 2000</TD>
<TD>7</TD>
<TD>9.0c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows NT4</TD>
<TD>無し</TD>
<TD>3相当</TD>
<TD>ServicePack6 で DirectX3 が提供される。<BR>ただし、3D機能のHAL無し版。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows ME</TD>
<TD>7.1</TD>
<TD>9.0c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98SE</TD>
<TD>6.1</TD>
<TD>9.0c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98</TD>
<TD>5.2</TD>
<TD>9.0c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95 OSR2～</TD>
<TD>無し</TD>
<TD>8.0a</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95</TD>
<TD>無し</TD>
<TD>8.0a</TD>
<TD>NEC PC-9800シリーズ用の最終は7。</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/19 OS のバージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
GetVersionEx で取得した Windows のバージョン。<BR>

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">バージョン</TD>
<TD>Major</TD>
<TD>Minor</TD>
<TD>Build</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8.1</TD>
<TD>6</TD>
<TD>3</TD>
<TD>9600</TD>
<TD>マニフェストの記述が無い場合は<BR>
Windows8 のバージョンを返す。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 8</TD>
<TD>6</TD>
<TD>2</TD>
<TD>9200</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 7</TD>
<TD>6</TD>
<TD>1</TD>
<TD>7600</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows Vista</TD>
<TD>6</TD>
<TD>0</TD>
<TD>6002</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows XP x64</TD>
<TD>5</TD>
<TD>2</TD>
<TD>3790</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows XP</TD>
<TD>5</TD>
<TD>1</TD>
<TD>2600</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 2000</TD>
<TD>5</TD>
<TD>0</TD>
<TD>2195</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows NT4</TD>
<TD>4</TD>
<TD>0</TD>
<TD>1381</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows ME</TD>
<TD>4</TD>
<TD>10</TD>
<TD>3000</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98SE</TD>
<TD>4</TD>
<TD>10</TD>
<TD>2222</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 98</TD>
<TD>4</TD>
<TD>10</TD>
<TD>1998</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95 OSR2～</TD>
<TD>4</TD>
<TD>0</TD>
<TD>1111<BR>1212</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Windows 95</TD>
<TD>4</TD>
<TD>0</TD>
<TD>950</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/06 OFN_ALLOWMULTISELECTのバッファサイズ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
OPENFILENAME::Flags に OFN_ALLOWMULTISELECT を指定して<BR>
GetOpenFileName を呼び出すと複数のファイルが選択できるようになる。<BR>
<BR>
OFN_ALLOWMULTISELECT 使用時のバッファサイズは下記のようにする。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
(指定ファイル数 * (MAX_PATH + 1) + 1) * sizeof(TCHAR);<BR>
</TD></TR>
</TABLE>
<BR>
※TCHAR は ShiftJIS(ASCII) なら 1byte。 unicode なら 2byteになる。<BR>
<BR>
バッファには下記のように格納される。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
path\0name\0name\0name\0\0<BR>
</TD></TR>
</TABLE>
<BR>
OFN_ALLOWMULTISELECT 使用時はパスとファイル名が分離されるので<BR>
ファイル名で MAX_PATH を埋め尽くす事はほとんど無く、指定ファイル数以上に<BR>
選択する事は可能。<BR>
<BR>
一部で「バッファサイズの限界はドキュメントに 2048 が限界と記載してあるが<BR>
実際には 2048 を超えても問題が無い」と言われているので調べてみると…<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
The MFC documentation for CFile-Dialog contains the following strange warning:<BR>
<BR>
When the user allocates their own buffer to accommodate OFN_ALLOWMULTISELECT,<BR>
the buffer can't be larger than 2048 or else everything gets corrupted<BR>
 (2048 is the maximum size). <BR>
<BR>
The limitation in question existed in Windows 95 and<BR>
 was fixed in Windows NT 4 and Windows 98,<BR>
 so the remarks do not apply to any modern version of Windows.<BR>
<BR>
<FONT  COLOR="#0000ff">
問題の制限はWindows 95に存在しWindows NT 4および<BR>
Windows 98に固定されました。したがって、<BR>
発言はウィンドウズのどんな現代版にも当てはまりません。<BR>
</FONT>
<BR>
※エキサイト翻訳<BR>
</TD></TR>
</TABLE>
<BR>
この問題は Windows95 の制限で Windows98/NT4 以降では修正されているらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/12/02 WM_USER の注意点</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ダイアログを使ったソフトの動作が不安定だったので調べてみた。<BR>
どうやら予期せぬタイミングで WM_USER が発生している事を突き止めた。<BR>
<BR>
ダイアログの定義で確かに WM_USER を使っているのを確認。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
#define DM_GETDEFID         (WM_USER+0)<BR>
#define DM_SETDEFID         (WM_USER+1)<BR>
#define DM_REPOSITION       (WM_USER+2)<BR>
</TD></TR>
</TABLE>
<BR>
とりあえず、(WM_USER+10) に書き換えてダイアログのメッセージと<BR>
重複しないようにしたら動作が安定した。<BR>
<BR>
どうしてこんな問題があるのか調べてみると…<BR>
<BR>
WM_USER はコントロール（ボタン等も含む）で使う為の定義らしい。<BR>
コントロールを扱う側は WM_APP を使うのが正しいらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/11/20 シェーダーモデル</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
シェーダーモデル と API バージョン。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>バージョン</TD>
<TD>DirectX</TD>
<TD>OpenGL</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>1.0</TD>
<TD>8.0</TD>
<TD>1.5+EXT</TD>
<TD>vertex 1.0～1.1 , pixel 1.0～1.4</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>2.0</TD>
<TD>9.0</TD>
<TD>2.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>2.0a</TD>
<TD>9.0b</TD>
<TD>2.0</TD>
<TD>nVIDIA 拡張</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>2.0b</TD>
<TD>9.0b</TD>
<TD>2.0</TD>
<TD>ATI 拡張</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>3.0</TD>
<TD>9.0c</TD>
<TD>2.1</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>4.0</TD>
<TD>10.x</TD>
<TD>3.x</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>5.0</TD>
<TD>11.x</TD>
<TD>4.x</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/11/19 DXGI</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
DirectX グラフィックス インフラストラクチャー (DXGI) は<BR>
DirectX 10 以降に搭載された機能。<BR>
<BR>
DirectX 9 までは解像度の切り替え（フルスクリーン化）やデバイス列挙等の<BR>
低レベル制御は DirectX Runtime が行っていたので DirectX がバージョンアップすると<BR>
I/F が変わって（ソースコードの）互換性が無くなると言うことがあった。<BR>
<BR>
でも DirectX 10 以降はこの低レベル制御の部分を別コンポーネント化したから<BR>
毎回、開発者が最新機能を使う為にこの部分を作り直す必要が無いよってことらしい。<BR>
<BR>
DXGI は DirectX Runtime とドライバ階層の間に入っていて、 <BR>
Vista 以降の OS で実装されているらしい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/10/19 Android (x86) とＡＲＭ用アプリの互換性</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
最新の Android (x86) には NDK で ARM 用のバイナリしか<BR>
作っていないアプリでもほとんど動作するらしい。<BR>
<BR>
なんでも Intel 製の「Houdini Binary Translator」と呼ばれるソフトが<BR>
Android に組み込まれていて、ARM 用のバイナリを x86 に変換している。<BR>
これにより約９割の ARM 専用のアプリが動作すると言われている。<BR>
<BR>
「Houdini Binary Translator」はＯＳ内部に組み込まれているようで、<BR>
一般ユーザーは意識することなく利用している状態になっている。<BR>
その為、「Houdini Binary Translator」を存在を知らない人も多いと思われる。<BR>
<BR>
国外製の安価な Android(x86) タブレットに「Houdini Binary Translator」が<BR>
組み込まれているかは不明。<BR>
<BR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/05/04 Android のファイルへのデータ保存</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
簡単にデータを保存するには Serializable を implements してシリアライズ化した<BR>
クラスを用意する。<BR>
<BR>
そのクラスを ObjectOutputStream の writeObject メソッドに指定すると<BR>
メンバの値はファイルに保存される。<BR>
ただし、static や transient 宣言していると保存対象にはならない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
class SaveData implements Serializable<BR>
{<BR>
&ensp;// シリアライズID<BR>
&ensp;static final long serialVersionUID = 123456;<BR>
&ensp;// 保存するメンバ<BR>
&ensp;public int _nDataVer;<BR>
&ensp;public String _strLastPath;<BR>
&ensp;public int _nNumber;<BR>
&ensp;public transient int _format; // 非シリアライズ変数は保存されない<BR>
&ensp;public static int _type; // 静的変数は保存されない<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
FileOutputStream から ObjectOutputStream を生成してクラスを保存する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
SaveData data;<BR>
data._nDataVer = 1;<BR>
data._strLastPath = "save";<BR>
data._number = 100;<BR>
<BR>
try<BR>
{<BR>
&ensp;//FileOutputStream fos = new FileOutputStream(_SD_EXT_FULLPATH);<BR>
&ensp;FileOutputStream fos = context.openFileOutput(_FILENAME,Context.MODE_PRIVATE);<BR>
&ensp;ObjectOutputStream oos = new ObjectOutputStream(fos);<BR>
&ensp;oos.writeObject(data);<BR>
&ensp;oos.close();<BR>
}<BR>
catch( Exception e )<BR>
{<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
保存したデータの読み込みは FileInputStream から ObjectInputStream を<BR>
生成して Serializable したクラスのインスタンスを復帰させる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
SaveData data;<BR>
try<BR>
{<BR>
&ensp;//FileInputStream fis = new FileInputStream(_SD_EXT_FULLPATH);<BR>
&ensp;FileInputStream fis = context.openFileInput(_FILENAME);<BR>
&ensp;ObjectInputStream ois = new ObjectInputStream(fis);<BR>
&ensp;data = (Serializable) ois.readObject();<BR>
&ensp;ois.close();<BR>
}<BR>
catch( Exception e )<BR>
{<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
保存したファイルにはクラス名とメンバ名をキーに値が保存されるので<BR>
保存メンバを変更すると読み込み時に例外が発生する。<BR>
順番を変えずに追加する場合には発生しないっぽい。<BR>
<BR>
これにより ProGuard を使っていると ON/OFF でクラス名とメンバ名に<BR>
相違が発生しデータが正しく読み込めない事になる。<BR>
また、ProGuard の難読化は変数の順番が異なると生成される名称も異なるので<BR>
この場合もデータが正しく読み込めない事になる。<BR>
<BR>
この問題は Serializable を implements したクラスは難読化を抑制するように<BR>
proguard-project.txt に追記して対策可能。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
-keep class * implements Serializable<BR>
{<BR>
&ensp;&lt;fields&gt;;<BR>
}<BR>
</TD></TR>
</TABLE>
<BR>
シリアライズ化したクラスを全て抑制したくない場合は該当クラスを<BR>
個別で全て記述すればいい。<BR>
<BR>
</TD></TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/04/16 Android のファイルサイズ限界</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
PC からのコード移植で気が付いた。<BR>
Android NDK で 2GB を超えるファイルにアクセス出来ない…。<BR>
<BR>
ファイルシステム的には 2GB を超えるファイルは存在可能なんだけど、<BR>
2GB を超えていると fopen() の時点で失敗するらしい。<BR>
<BR>
32bit(4 byte) なら 4GB まで操作出来そうだけど fseek は現在位置からマイナス方向に<BR>
移動指定が可能なので符号ビットが必要になり、2GB までしか扱えないってことか。<BR>
<BR>
fseek の 位置指定は long 型。特に #if も無いので変化しそうにない。<BR>
NDK の platforms レベル19のヘッダを参照しても long。<BR>
sizeof(long) として確認したけど 32bit 環境なので当然 4 byte。<BR>
<BR>
fseeko があるので off_t を調べたけどこれも 4 byte …。<BR>
fseeko64 は MinGW 専用っぽいのでこれも無理。<BR>
fseeki64 は VC 専用っぽいのでこれも無理。<BR>
<BR>
32bit Linux 環境用のマクロ定義<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#define _LARGEFILE64_SOURCE<BR>
#define _FILE_OFFSET_BITS 64<BR>
#include &lt;stdio.h&gt;<BR>
</TD>
</TR>
</TABLE>
これも変化無し。<BR>
<BR>
NDK のヘッダを検索していると lseek64 を発見した。<BR>
これは 「Linux 用でCRT間の移植性が落ちるからあまり使わないでね」と<BR>
注意があったけど、使えるなら構わない。<BR>
lssek64 は NDK r6 には無い。NDK r8 にはあった。<BR>
<BR>
Android のソースを確認すると隠し関数？の __llseek を呼び出しているだけだった。<BR>
<BR>
2GB 超えファイルを open() で開くと失敗して errno に EOVERFLOW が設定される。<BR>
open() の引数に O_LARGEFILE を設定すれば失敗しない。<BR>
<BR>
Windows 環境の open() とは引数に使う定義の互換性が無いので注意。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#include &lt;fcntl.h&gt;<BR>
#include &lt;sys/stat.h&gt;<BR>
#include &lt;unistd.h&gt;<BR>
fd = open( filename.O_RDONLY|O_LARGEFILE,666 );<BR>
if( fd &lt; 0 )return;<BR>
size64 = lseek64( fd,0,SEEK_END );<BR>
</TD>
</TR>
</TABLE>
<BR>
これでファイルサイズが正常に取得出来れば 2GB 超え対応の完了。<BR>
Android 2.3 系でも動作した。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/04/01 SJIS ダメ文字</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
2byte 文字の 2byte 目が 0x5c ("\") だと 1byte の "\" と誤認してしまう文字。<BR>
UNICODE (UTF8,UTF-16) ではこの問題は発生しない。<BR>
<BR>
これは VC から GCC に移植するケースやパス処理で問題になる。<BR>
<BR>
SJIS を認識しない C/C++ コンパイラでダメ文字 "表" を記述すると…<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
// ID一覧表<BR>
static int id[]={20,40,50};<BR>
v = id[0];<BR>
</TR>
</TD>
</TABLE>
<BR>
"表" が "\" と解釈されてコメント行に連結されてしまう。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
// ID一覧表static int id[]={20,40,50};<BR>
v = id[0];<BR>
</TR>
</TD>
</TABLE>
<BR>
変数 id は存在しない事になり、コンパイルエラーになる。<BR>
<BR>
日本語コメントは /**/ にするか、最後に適当な文字を追加すれば対策可能。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
/* ID一覧表 */<BR>
// ID一覧表-<BR>
</TR>
</TD>
</TABLE>
<BR>
Microsoft 系OSはパスの区切りに "\" を使うのでフルパスからファイル名を<BR>
単純に "\" で抽出するプログラムコードを作成すると下記のようなパスで<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
c:\data\制御ソフト.txt<BR>
</TR>
</TD>
</TABLE>
<BR>
"ソ"がダメ文字なので「フト.txt」で抽出されてしまう可能性がある。<BR>
mbs 系の文字列操作関数を使えば対策出来る。<BR>
<BR>
ダメ文字の一覧。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR WIDTH="160" BGCOLOR="#505050">
<TD>文字</TD>
<TD>ShiftJIS</TD>
<TD>備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>―</TD>
<TD>0x815c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ソ</TD>
<TD>0x835c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Ы</TD>
<TD>0x845c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>噂</TD>
<TD>0x895c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>浬</TD>
<TD>0x8a5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>欺</TD>
<TD>0x8b5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>圭</TD>
<TD>0x8c5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>構</TD>
<TD>0x8d5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>蚕</TD>
<TD>0x8e5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>十</TD>
<TD>0x8f5c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>申</TD>
<TD>0x905c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>曾</TD>
<TD>0x915c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>箪</TD>
<TD>0x925c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>貼</TD>
<TD>0x935c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>能</TD>
<TD>0x945c</TD>
<TD>注意コメント //性能 、//分解能 、//知能</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>表</TD>
<TD>0x955c</TD>
<TD>注意コメント //一覧表</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>暴</TD>
<TD>0x965c</TD>
<TD>注意文字 //暴れる 、//暴走</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>予</TD>
<TD>0x975c</TD>
<TD>注意文字 //予約 、//予定 、//予報</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>禄</TD>
<TD>0x985c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>兔</TD>
<TD>0x985c</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>-</TD>
<TD>0x??5c</TD>
<TD>喀 媾 彌 拿 杤 歃 濬 畚 秉 綵 臀 藹 觸 軆 鐔 饅 鷭 偆 砡</TD>
</TR>
</TABLE>
<BR>
Perl だと "|" (0x7c) で同様の問題が発生する。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2013/01/07 テキストのスクロール設定</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
TextView でサイズから文字がはみ出た場合の処理を android:ellipsize で<BR>
指定が出来るとあったのでスクロールを設定する事にした。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
android:ellipsize="marquee"<BR>
</TD>
</TR>
</TABLE>
<BR>
を試してみたが改行されて２行になってしまう。<BR>
<BR>
調べてみると行数の設定をすれば良いとあったので試してみる…<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
android:singleLine="true"<BR>
android:scrollHorizontally="true"<BR>
</TD>
</TR>
</TABLE>
<BR>
1行になっただけで、はみ出した文字列は動く様子がない。<BR>
<BR>
バージョンがダメなのかと調べてみたけど Android 2.x でも使えるみたい。<BR>
<BR>
さらに調べてみるとフォーカスも設定しているケースがあったので<BR>
これを試してみるとスクロールしてくれた。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
android:focusable="true"<BR>
android:focusableInTouchMode="true"<BR>
</TD>
</TR>
</TABLE>
<BR>
何回もスクロールする必要は無いのでスクロール回数を指定して完了。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
android:marqueeRepeatLimit="1"<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/12/10 セキュリティ強化関数</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VS2005 以降で文字列操作系の関数を使うとセキュリティに問題が無い、<BR>
新しい関数を使ってくれと警告が出る。<BR>
<BR>
これらの関数は不正なデータを使ってバッファ領域を超えて<BR>
他のメモリ領域が書き換えられる可能性がある。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>VS2003 以前</TD>
<TD>VS2005 以降</TD>
<TD>問題点</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>sprintf</TD>
<TD>sprintf_s</TD>
<TD>バッファサイズをチェックしていない</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>strcpy</TD>
<TD>strcpyf_s</TD>
<TD>バッファサイズをチェックしていない</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>strcat</TD>
<TD>strcat_s</TD>
<TD>バッファサイズをチェックしていない</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>fopen</TD>
<TD>fopen_s</TD>
<TD>CRT が保持するポインタを返す。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>localtime</TD>
<TD>localtime_s</TD>
<TD>CRT が保持するポインタを返す。</TD>
</TR>
</TABLE>
<BR>
「バッファ管理はしっかりやっているので大丈夫です。」という人は<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#define _CRT_SECURE_NO_DEPRECATE<BR>
</TD>
</TR>
</TABLE>
として警告が出ないようにしても良いかも。<BR>
<BR>
<BR>
ちなみに新関数でバッファオーバーを検知すると失敗するのではなく<BR>
アサートが発生してプログラムが強制停止させられる。<BR>
<BR>

</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/12/01 64ビット環境の変数サイズ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Microsoft 系 64bit コンパイラは LLP64 モデル。<BR>
gcc 系の 64bit コンパイラは LP64 モデル。<BR>

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">定義</TD>
<TD>16</TD>
<TD>ILP32</TD>
<TD>LP64</TD>
<TD>LLP64</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>char</TD>
<TD>1</TD>
<TD>1</TD>
<TD>1</TD>
<TD>1</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>short</TD>
<TD>2</TD>
<TD>2</TD>
<TD>2</TD>
<TD>2</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>int</TD>
<TD>2</TD>
<TD>4</TD>
<TD>4</TD>
<TD>4</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>long</TD>
<TD>4</TD>
<TD>4</TD>
<TD>8</TD>
<TD>4</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>long long (*1)</TD>
<TD>-</TD>
<TD>8</TD>
<TD>8</TD>
<TD>8</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__int64 (*2)</TD>
<TD>-</TD>
<TD>8</TD>
<TD>8</TD>
<TD>8</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>ポインタ</TD>
<TD>2</TD>
<TD>4</TD>
<TD>8</TD>
<TD>8</TD>
</TR>
</TABLE>
<BR>
(*1) 古いコンパイラは対応していない。<BR>
(*2) Microsoft の独自拡張。gcc は対応していない。<BR>

<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/11/02 環境の判別方法</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">

<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">定義済みマクロ</TD>
<TD>意味</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__GNUC__</TD>
<TD>コンパイラは gcc</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__clang__</TD>
<TD>コンパイラは clang</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>_MSC_VER</TD>
<TD>コンパイラは Visual C/C++</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__ANDROID__</TD>
<TD>ターゲット環境は Android</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__linux__</TD>
<TD>ターゲット環境は Linux</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__x86_64__</TD>
<TD>ターゲット環境は 64bit OS (gcc系？)</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>_WIN32</TD>
<TD>ターゲット環境は Windows 32bit</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>_WIN64</TD>
<TD>ターゲット環境は Windows 64bit</TD>
</TR>
</TABLE>

<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/10/14 Linux のマルチスレッド関数</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
マルチスレッドで使いそうな関数。<BR>
<BR>
pthread_create() : スレッドの生成。<BR>
pthread_join() : スレッドの終了待ち。<BR>
pthread_mutex_init() : 排他処理の初期化。<BR>
pthread_mutex_lock() : 排他処理のロック開始。<BR>
pthread_mutex_trylock() : 排他処理の条件ロック開始。<BR>
pthread_mutex_unlock() : 排他処理のロック終了。<BR>
pthread_mutex_destroy() : 排他処理の開放。<BR>
pthread_cond_init() : 条件付き休止の初期化。<BR>
pthread_cond_signal() : 条件付き休止の解除（単体スレッド）。<BR>
pthread_cond_broadcast() : 条件付き休止の初期化（複数スレッド）。<BR>
pthread_cond_wait() : 条件付き休止の開始。<BR>
pthread_cond_timedwait() : 条件付き休止の開始。<BR>
pthread_cond_destroy() : 条件付き休止の開放。<BR>
<BR>
sleep() : 1 を指定すると1秒休止する。<BR>
usleep() : 1000000 を指定すると1秒休止する。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/10/07 NDK の static library リンク</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
別のプロジェクトで生成したスタティックライブラリをリンクする。<BR>
<BR>
指定されたフォルダを作成してライブラリとヘッダをコピーする。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
jni/external/include<BR>
jni/external/lib<BR>
</TD>
</TR>
</TABLE>
<BR>
後は android.mk を書き換える。<BR>
<BR>
ライブラリ名は先頭に lib を付ける必要があるが、自動的に付与されるので<BR>
android.mk では lib を省略して記述する。<BR>
<BR>
libxfile.a をリンクする場合。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
LOCAL_C_INCLUDES := $(LOCAL_PATH)/external/include<BR>
LOCAL_LDLIBS    := -llog -lGLESv1_CM<BR>
LOCAL_LDLIBS    += -Lexternal/lib/ -lxfile<BR>
</TD>
</TR>
</TABLE>
<BR>
と記述したら以下の警告が出た。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
Android NDK: WARNING:jni/Android.mk:name: non-system libraries in linker flags: -lname<BR>
Android NDK: This is likely to result in incorrect builds. Try using LOCAL_STATIC_LIBRARIES<BR>
Android NDK: or LOCAL_SHARED_LIBRARIES instead to list the library dependencies of the<BR>
Android NDK: current module<BR>
</TD>
</TR>
</TABLE>
<BR>
指定のライブラリはシステム(CRT？)には存在しない。<BR>
LOCAL_STATIC_LIBRARIES か LOCAL_SHARED_LIBRARIES を<BR>
試してみてくれってことらしい。<BR>
<BR>
一応、リンクは成功してビルドは正常に完了している。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
LOCAL_STATIC_LIBRARIES := xfile<BR>
</TD>
</TR>
</TABLE>
<BR>
を追加してみたけど変化は無かった。<BR>
<BR>
ググっても警告だから無視して問題ないみたいと書かれていた。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/10/06 NDK gcc のバージョン指定</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
NDK のバージョンによっては toolchains フォルダに複数の gcc が入っている。
<BR>
最新のコンパイラを使用したい場合や逆に古いNDKと互換性が欲しい場合などに<BR>
Application.mk に設定すればいい。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#use gcc 4.6<BR>
NDK_TOOLCHAIN_VERSION=4.6<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/09/08 NDK の API Level 指定方法</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
OpenSL のコードを書いたらヘッダが無いとエラーになった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
error SLES/OpenSLES.h: No such file or directory<BR>
</TD>
</TR>
</TABLE>
<BR>
NDK のフォルダを検索すると andoroid-8 以前には無いが andoroid-9 にはある。<BR>
<BR>
API Level の指定が間違っているとわかったので eclipse のプロジェクト設定を<BR>
変更してからビルドしたけど効果なし。<BR>
<BR>
ググったらコマンドプロンプトから入力を試せとあったので<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
ndk-build TARGET_PLATFORM=android-9<BR>
</TD>
</TR>
</TABLE>
<BR>
実行してみると確かにビルドが通る。<BR>
<BR>
NDK のサンプルはこんな事しなくてもビルドが通るので調べてみたら<BR>
Application.mk に記述してあった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
# The ARMv7 is significanly faster due to the use of the hardware FPU<BR>
#APP_ABI := armeabi-v7a<BR>
<BR>
# CPU NEON code<BR>
#LOCAL_ARM_NEON := true<BR>
<BR>
# target ANDROID 2.3.1<BR>
APP_PLATFORM := android-9<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/09/02 NDK でログ出力</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ログ出力するコードを作ったらエラーが出てビルドが通らない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
jni/xx.c:100: undefined referance to `__android_log_print'<BR>
</TD>
</TR>
</TABLE>
<BR>
エラーに行数が出ていたのでコンパイルエラーと思っていたが<BR>
調べてみるとリンクエラーだった…<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
LOCAL_LDLIBS    += -llog<BR>
</TD>
</TR>
</TABLE>
<BR>
で解決した。<BR>
<BR>
VC のリンクエラーはソースの該当行数を表示しないので<BR>
gcc も同じだと勘違いしていた。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/08/26 Android の ネイティブから使える機能</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android バージョン別の NDK から使える機能。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>func / ver</TD>
<TD>1.6</TD>
<TD>2.0</TD>
<TD>2.2</TD>
<TD>2.3.1</TD>
<TD>2.3.3</TD>
<TD>3.0</TD>
<TD>4.0</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>API Level</TD>
<TD>4</TD>
<TD>5</TD>
<TD>8</TD>
<TD>9</TD>
<TD>10</TD>
<TD>11</TD>
<TD>14</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>JNI</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>NativeActivity</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenGL ES 1.1</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenGL ES 2.0</TD>
<TD>-</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenSL ES</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Sensor/Touch</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
<TD>○</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Media Dec/Enc</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>-</TD>
<TD>○</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/26 Android SurfaceView の破棄されるタイミング</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
SurfaceView は終了時だけでなく、画面向き変更時やスリープ移行時等の<BR>
画面が切り替わるタイミングでも破棄される。<BR>
<BR>
このタイミングを検知するには SurfaceHolder.Callback の<BR>
surfaceDestroyed をオーバライドで可能になる。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
 public abstract void surfaceDestroyed (SurfaceHolder holder)<BR>
Added in API level 1<BR>
</TD></TR>
</TABLE>
<BR>
いろいろ解説サイトを見ていると surfaceDestroyed は<BR>
<FONT COLOR="#ff0000">サーフェイスが破棄された後</FONT>に呼ばれると記述されている事が多い。<BR>だとしたら描画スレッドで不正なアクセスが多発するハズだが、あまり聞かない。<BR>
<BR>
Android の公式サイトで API の解説を探してみると<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
This is called immediately before a surface is being destroyed.<BR>
After returning from this call, you should no longer try to access this surface.<BR>
If you have a rendering thread that directly accesses the surface,<BR>
you must ensure that thread is no longer touching the Surface before returning from this function.<BR>
<BR>
<FONT COLOR="#0000ff">
表面が破壊されるすぐ前に、これは呼ばれる。<BR>
この呼び出しから戻った後に、あなたはもうこの表面にアクセスしようとするべきではない。<BR>
もしあなたが、表面に直接アクセスするスレッドを持っているならば、<BR>
あなたは、この機能から戻る前にもうスレッドが表面に触れないことを保証しなければならない。<BR>
</FONT>
<BR>
※エキサイト翻訳<BR>
</TD></TR>
</TABLE>
<BR>
やっぱり<FONT COLOR="#ff0000">サーフェイスが破棄される前</FONT>に呼ばれるようだ。<BR>
API 側の要求としては surfaceDestroyed の終わりに達する時には<BR>
描画スレッドが停止していること。<BR>
サンプルコードの大半は surfaceDestroyed でスレッドを停止させているが<BR>
スレッドが完全に停止した事を確認しているものはほとんど無い。<BR>
<BR>
サンプルのようにスレッドの処理が軽い場合には問題は発生しないが<BR>
スレッドで重い処理を行っていた場合はスレッドの停止処理が間に合わず<BR>
サーフェイスにアクセスしてしまう事も考えられるので注意が必要。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/20 Deprecated Thread methods are not supported</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Java でマルチスレッドを Thread.stop() を使って停止させると例外が発生する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
Deprecated Thread methods are not supported.<BR>
java.lang.UnsupportedOperationException<BR>
at java.lang.VMThread.stop(VMThread.java:85)<BR>
at java.lang.Thread.stop(Thread.java:1280)<BR>
</TD></TR>
</TABLE>
<BR>
Deprecated なので使えるけど非推奨になってるらしい。<BR>
スレッドが強制終了されるので状態があいまいになる可能性があるとのこと。<BR>
<BR>
スレッド終了フラグを参照して無限ループを抜けて run メソッドの最後に<BR>
行き着くようなプログラムを作り、終了フラグを有効にしてもスレッドが終了しない<BR>
場合に最終手段として Thread.stop() を使うのが理想なのかも知れない。<BR>
<BR>
メインスレッド以外のスレッドが１つしか無いのなら Thread.interrupt() を<BR>
使うのも良いかもしれない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
do<BR>
{<BR>
&ensp;//スレッドで行う処理<BR>
<BR>
&ensp;//ウエイト前に確認する<BR>
&ensp;life = Thread.interrupted();<BR>
&ensp;if( ! life )<BR>
&ensp;{<BR>
&ensp;&ensp;break;<BR>
&ensp;}<BR>
<BR>
&ensp;//sleepでウエイトを入れる<BR>
&ensp;try<BR>
&ensp;{<BR>
&ensp;&ensp;Thread.sleep( 100 );<BR>
&ensp;}<BR>
&ensp;catch (InterruptedException e)<BR>
&ensp;{<BR>
&ensp;&ensp;Log.i( _TAG,"InterruptedException()\n" );<BR>
&ensp;&ensp;Thread.interrupted();	// フラグクリアする<BR>
&ensp;&ensp;life = false;<BR>
&ensp;}<BR>
}<BR>
while( life );<BR>
</TD></TR>
</TABLE>
<BR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/15 android ログの種類</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Android のログ出力はレベルを指定して出力する事が出来る。<BR>
eclipse を使用しているならば logcat の文字列に色が付く。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD>コード</TD>
<TD>種別</TD>
<TD>eclipse<BR>logcat</TD>
<TD WIDTH="200">意味、用途</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Log.v(_TAG,"verbose");</TD>
<TD>verbose</TD>
<TD>黒</TD>
<TD>冗長な表示（詳細）</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Log.d(_TAG,"debug");</TD>
<TD>debug</TD>
<TD>青</TD>
<TD>デバッグ</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Log.i(_TAG,"info");</TD>
<TD>info</TD>
<TD>緑</TD>
<TD>情報</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Log.w(_TAG,"warning");</TD>
<TD>warning</TD>
<TD>黄</TD>
<TD>警告</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Log.e(_TAG,"error");</TD>
<TD>error</TD>
<TD>赤</TD>
<TD>エラー</TD>
</TR>
</TABLE>
<BR>
<BR>
NDK でも同様に android/log.h でレベルが定義されている。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
typedef enum android_LogPriority {<BR>
&ensp;ANDROID_LOG_UNKNOWN = 0,<BR>
&ensp;ANDROID_LOG_DEFAULT,    /* only for SetMinPriority() */<BR>
&ensp;ANDROID_LOG_VERBOSE,<BR>
&ensp;ANDROID_LOG_DEBUG,<BR>
&ensp;ANDROID_LOG_INFO,<BR>
&ensp;ANDROID_LOG_WARN,<BR>
&ensp;ANDROID_LOG_ERROR,<BR>
&ensp;ANDROID_LOG_FATAL,<BR>
&ensp;ANDROID_LOG_SILENT,     /* only for SetMinPriority(); must be last */<BR>
} android_LogPriority;<BR>
</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>



<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/14 android アプリ連続起動の問題</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
onPause() の後、onStop() が呼ばれる前に再度アプリが起動されると<BR>
onCreate() が呼ばれた後に onStop() 、onDestroy() が呼ばれる。<BR>
しかも onDestroy() が呼ばれているのにアプリは終了しない。<BR>
<BR>
結果、インスタンスの無いクラスにアクセスして落ちる…<BR>
<BR>

●プロセスが存在しない状態から起動<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
00:40:59.716: D/Life:(13469): constructor()<BR>
00:40:59.716: D/Life:(13469): onCreate()<BR>
00:40:59.796: D/Life:(13469): onStart()<BR>
00:40:59.796: D/Life:(13469): onResume()<BR>
00:40:59.836: D/Life:(13469): onWindowFocusChanged(true)<BR>
</TD>
</TR>
</TABLE>
<BR>

●BACKキーで終了<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
00:41:44.816: D/Life:(13469): onUserInteraction()<BR>
00:41:44.816: D/Life:(13469): onKeyDown(4)<BR>
00:41:44.996: D/Life:(13469): onUserInteraction()<BR>
00:41:45.006: D/Life:(13469): onPause()<BR>
<FONT COLOR="#00FF00">
00:41:46.407: </FONT>D/Life:(13469): onStop() ←１秒以上の空き時間がある。<BR>
00:41:46.407: D/Life:(13469): onDestroy()<BR>
</TD>
</TR>
</TABLE>
<BR>

●BACKキーで終了後、１秒以内にアプリを起動する<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
00:47:39.032: D/Life:(13469): onUserInteraction()<BR>
00:47:39.032: D/Life:(13469): onKeyDown(4)<BR>
00:47:39.122: D/Life:(13469): onUserInteraction()<BR>
00:47:39.132: D/Life:(13469): onPause()<BR>
00:47:39.172: D/Life:(13469): onWindowFocusChanged(false)<BR>
<FONT COLOR="#00FF00">
00:47:40.223: D/Life:(13469): onCreate()<BR>
00:47:40.243: D/Life:(13469): onStart()<BR>
00:47:40.243: D/Life:(13469): onResume()<BR>
00:47:40.293: D/Life:(13469): onWindowFocusChanged(true)<BR>
</FONT>
00:47:40.423: D/Life:(13469): onStop()<BR>
00:47:40.423: D/Life:(13469): onDestroy()<BR>
</TD>
</TR>
</TABLE>
<BR>

この現象は android 2.3.3 で確認してるが<BR>
他のバージョンでも発生するのだろうか…。<BR>
<BR>
連続起動した場合にプロセスも変わっていないので<BR>
（コンストラクタが呼ばれていない）<BR>
プロセスを使った判別は無理と思われる。<BR>
<BR>
↓の２つの前提条件が正しいと仮定して<BR>
・onPause() と onResume() は対になっている。<BR>
・onStop() 、onDestroy() は onPause() の後にしか呼ばれない。<BR>
<BR>
1. static なフラグを用意する。<BR>
2. onPause() でフラグを true に設定。<BR>
3. onResume() でフラグを false に設定。<BR>
4. フラグが false なら onStop() 、onDestroy() は処理しない。<BR>
(フラグに関係なく super は実行する。)<BR>
<BR>
で回避できた。<BR>
<BR>
さらに onStop() もしくは onDestroy() でデータ保存してると<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
onPause()<BR>
<FONT COLOR="#00FF00">
onCreate() ←保持データの読み込み、変更が起動時に戻る。<BR>
onStart()<BR>
onResume()<BR>
</FONT>
onStop() ←起動時の状態に戻ったデータを保存。<BR>
onDestroy()<BR>
</TD>
</TR>
</TABLE>
<BR>
とデータの変更が元に戻った後に保存されるので保持されない。<BR>
onPause() で保存すれば対応できるけど保存処理に<BR>
長い時間がかかる場合は呼ばれる頻度が高い onPause() ではちょっと困る。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/08 android の match_parent</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
android 2.2 (API Level 8)から追加されたレイアウトの幅の定義。<BR>
機能は fill_parent と同じ。<BR>
andoroid 2.1 で match_parent を使うと落ちる。<BR>
<BR>
これにより fill_parent は deprecated (非推奨)になった。<BR>
<BR>
ADT r20 以降でも自動生成されるレイアウトの XML は<BR>
fill_parent ではなく match_parent になっている。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/07/07 android-support-v4.jar</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ADT r20 以降ではプロジェクトを作成すると自動で組み込まれる。<BR>
<BR>
android-support-v4.jar は Support Library と呼ばれ、android 3.0 で追加された<BR>
新しいUI機能を android 3.0 未満で使えるようにするもの。<BR>
<BR>
つまり<BR>
・ターゲットが android 3.0 以降で追加機能を直接使う場合。<BR>
・ターゲットが android 3.0 未満で追加機能を使わない場合。<BR>
は不要となる。<BR>
<BR>
プロジェクトディレクトリの libs に置かれている android-support-v4.jar を<BR>
削除すると apk のサイズが約 450KB ほど小さくなる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/28 Android の ProGuard</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Java は C/C++ と違い、機械語ではなく中間コードで配布される形になるので<BR>
逆コンパイルすると綺麗なコードが生成される可能性が高い。<BR>
<BR>
SDK に付属している ProGuard を使うと、クラスやメソッド、メンバの名称を<BR>
意味の無い文字列に変更し、逆コンパイルしてもわかりづらいように難読化してくれる。<BR>
オプションで最適化も可能だが Android SDK の初期設定では無効に設定されている。<BR>
<BR>
SDKバージョンが古いと ProGuard の設定ファイル名が異なる。<BR>
<BR>
プロジェクトを作成時に自動的に生成される project.properties の次の1行から<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#proguard.config=${sdk.dir}\tools\proguard\proguard-android.txt:proguard-project.txt<BR>
</TD>
</TR>
</TABLE>
先頭の # を消してコメントを解除すると ProGuard が有効になる。<BR>
<BR>
ProGuard の細かい設定は SDK フォルダとプロジェクトに存在する<BR>
２つのファイルの記述が結合されて反映される。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
(SDK_PATH)\tools\proguard\proguard-android.txt<BR>
(PROJECT_PATH)\proguard-project.txt<BR>
</TD>
</TR>
</TABLE>
<BR>
ProGuard を使用して apk を生成すると ProGuard の出力フォルダが<BR>
作成されるので、その中にある mapping.txt で難読化の内容が確認可能。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
(project)\proguard\mapping.txt<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/25 デバッグビルドとリリースビルド</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
ビルドすると自動生成される<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
/gen/BuildConfig.java<BR>
</TD>
</TR>
</TABLE>
<BR>
BuildConfig.DEBUG の値(true/false)を判定すればデバッグモード、リリースモードを<BR>
判定する事が出来る。<BR>
<BR>
通常時はデバッグモード。認証付き apk 生成時はリリースモードになる。<BR>
<BR>
ただし、Eclipse の [Build Automatically] が有効になっていると<BR>
正しく切り替えが行われないバグがある。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/17 レイアウトのファイル名</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
レイアウトの XML のファイル名を Game.xml にしたらエラーが出た。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
res\layout\Game.xml: Invalid file name: must contain only [a-z0-9_.]<BR>
</TD>
</TR>
</TABLE>
<BR>
小文字アルファベットと数字しか使えないらしい。<BR>
"Game.xml" を "game.xml" に変更したら問題は解消された。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/16 ドット(.)の警告</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Stringタグに「Loading...」と入力すると警告が出て表示が正しくない。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
Replace "..." with ellipsis character (・・・,&&,#8230;)?<BR>
</TD>
</TR>
</TABLE>
<BR>
ドットを3つ続けて記述しているのが問題らしい。<BR>
一部の記号文字は""で括らないと正常に表示できない。<BR>
<BR>
正常に表示するには「Loading"."".""."」と書き換える必要がある。<BR>
@ 等の他の記号も""で括る必要がある。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/09 weight 使用時の警告</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
android のレイアウトで weight を使うと警告が出ることがある。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
Use a layout_width of 0dip instead of wrap_content for better performance<BR>
Use a layout_width of 0dip instead of fill_parent for better performance<BR>
</TD>
</TR>
</TABLE>
<BR>
これはパフォーマンス低下の警告。<BR>
無視しても構わないけど width や height を 0dip に変更すると<BR>
解消されることが多い。<BR>
<BR>
入れ子になるようなレイアウトで使用した時の警告。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
Nested weights are bad for performance<BR>
</TD>
</TR>
</TABLE>
<BR>
これの対策は不明。<BR>
全てのレイアウトに android:layout_weight 記述すれば<BR>
解決するとか…（未確認）。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/06/02 android インストール失敗</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
昔のツールで生成した著名なしの apk をインストールすると<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
INSTALL_PARSE_FAILED_NO_CERTIFICATES<BR>
</TD>
</TR>
</TABLE>
が発生して失敗する。<BR>
<BR>
対策：著名した apk を作る。<BR>
<BR>
同じアプリでも異なった著名で作成したアプリだと<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
INSTALL_PARSE_FAILED_NO_CERTIFICATES<BR>
</TD>
</TR>
</TABLE>
が発生して失敗する。<BR>
<BR>
対策：アプリをアンインストールしてからインストールする。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/05/28 android 実機転送</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
コマンドプロンプトを使ってアプリを転送する方法。<BR>
<BR>
複数のデバイスがあると「どれに転送するかわからない」とエラーになってしまう。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
C:\android\platform-tools>adb install -r hoge.apk<BR>
error: more than one device and emulator<BR>
</TD>
</TR>
</TABLE>
<BR>
デバイス一覧でシリアルを確認して<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
C:\android\platform-tools>adb devices<BR>
List of devices attached<BR>
emulator-5554   device<BR>
192.168.1.1:5555      device<BR>
</TD>
</TR>
</TABLE>
<BR>
シリアル指定で実行する。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
C:\android\platform-tools>adb -s 192.168.1.1:5555 install -r hoge.apk<BR>
557 KB/s (35594 bytes in 0.062s)<BR>
        pkg: /data/local/tmp/hoge.apk<BR>
</TD>
</TR>
</TABLE>
<BR>
Wi-Fi接続、VMware接続だと無理っぽいけど、USBとエミュレータを<BR>
区別したいだけなら -d(USB)と-e(emu)で出来る。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
adb -d install -r hoge.apk<BR>
adb -e install -r hoge.apk<BR>
</TD>
</TR>
</TABLE>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/04/21 VC6 で使える最新SDK</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC6 で Windows SDK v7.0 を使おうとするとビルドで<BR>
非対応の構文 deprecated でエラーになり、失敗してしまう。<BR>
<BR>
一応、VS2008EE 付属の Windows SDK v6.0A であれば警告が出るものの<BR>
サービスパックを当てた VC6 ならビルドを通す事はできる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/04/14 OpenWatom C/C++ 1.9 vs Pentium ODP(P24)</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Watcom の最適化オプションを変えると、どのくらい最適化されるか調べてみた。<BR>
<BR>
MP3 をファイルからメモリに読み込んで再生１秒間分のデコード処理のみを<BR>
RDTSC 命令を使って測定した結果。（出力バッファはそのままで再生はしない。）<BR>
<BR>
mp3dec_0　基準 -ot -s <BR>
 -- 65,920,972 Clock<BR>
<BR>
mp3dec_1　最適化 -ot -s -ob<BR>
 -- 64,202,550 Clock<BR>
mp3dec_2　最適化 -ot -s -ol<BR>
 -- 63,666,060 Clock<BR>
mp3dec_3　最適化 -ot -s -oc<BR>
 -- 65,920,930 Clock<BR>
mp3dec_4　最適化 -ot -s -oi<BR>
 -- 65,948,400 Clock<BR>
mp3dec_5　最適化 -ot -s -oa<BR>
 -- 65,910,592 Clock<BR>
mp3dec_6　最適化 -ot -s -or<BR>
 -- 56,722,842 Clock<BR>
mp3dec_7　最適化 -ot -s -oh<BR>
 -- 67,827,725 Clock<BR>
mp3dec_8　最適化 -ot -s -om<BR>
 -- 65,924,327 Clock<BR>
mp3dec_9　最適化 -ot -s -on<BR>
 -- 65,918,147 Clock<BR>
mp3dec_a　最適化 -ot -s -op<BR>
 -- 68,465,363 Clock<BR>
mp3dec_b　最適化 -ot -s -oe<BR>
 -- 65,922,010 Clock<BR>
<BR>
mp3dec_x　最適化 -ot -s -oblciarmne<BR>
 -- 54,336,913 Clock<BR>
<BR>
※ P5系では -op で遅くなっているが最近の CPU では結構速くなる。<BR>
※ P5系では -ol はちょい速だが、最近の CPU では結構速くなる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/02/05 OpenWatom C/C++ 1.9 option2</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
最速の32ビットインテルコードを生成するための推奨オプションは、以下の通りです。<BR>
<BR>
※Pentium Pro<BR>
　　/onatx /oh /oi+ /ei /zp8 /fp6<BR>
<BR>
※Pentium<BR>
　　/onatx /oh /oi+ /ei /zp8 /5 /fp5<BR>
<BR>
※486<BR>
　　/onatx /oh /oi+ /ei /zp8 /4 /fp3<BR>
<BR>
<BR>
すべてのプロセッサに対して良好な性能を期待できるオプションは、以下の通りです。<BR>
※386、486，Pentium<BR>
　　/onatx /oh /oi+ /ei /zp8 /5 /fp3<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2012/01/29 OpenWatom C/C++ 1.9 option</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
※ /ot<BR>
コード生成過程においてコードサイズに一切構わず、より速いコード順序を<BR>
選択するためには必ず指定しなくてはなりません。 <BR>
<BR>
※ /ox<BR>
”obmiler”と”s”オプションの組み合わせと同等の効果をもたらします。<BR>
<BR>
※ /ob _ Branch prediction<BR>
コンパイラ/コード生成器においての分岐予測を考慮したコードを生成します。<BR>
<BR>
※ /ol _ Loop optimizations<BR>
ループ最適化の実行を行います。<BR>
<BR>
※ /oc _ Call/return optimizations<BR>
呼び出しの最適化を行います。<BR>
<BR>
※ /oi _ In-line intrinsic functions<BR>
組み込み関数のインライン展開を行います。<BR>
<BR>
※ /oi+ _ ???<BR>
C++コンパイラで組み込み関数をインラインに展開します。（C++専用版です。）<BR>
さらに、inline_depthを最大値（255）に設定します。<BR>
初期値では、inline_depthの値は3となります。<BR>
inline_depthの値は、C++のinline_depthプラグマを使用して変更することもできます。<BR>
<BR>
※ /oa _ Relax alias checking<BR>
コンパイラの別名チェックする基準を「ゆるく」します。 <BR>
<BR>
※ /or _ Instruction scheduling<BR>
パイプラインの停止を避けるための命令再発行を考慮したコードを生成します。<BR>
<BR>
※ /oh _ Allow Repeated optimizations<BR>
オプションは、最適化の繰り返しを試行します。<BR>
（コンパイルに長時間かかりますが、より最適化されたコードを生成します）<BR>
<BR>
※ /om _ Math optimizations<BR>
サイン、コサイン、平方根のような数学関数においてインラインの387命令を生成します。<BR>
<BR>
※ /on _ Numerically unstable optimizations<BR>
コンパイラが浮動小数点の除算を乗算に変換して置き換えます。<BR>
これはより速いコードを生成しますが（乗算は除算より速いため）、<BR>
計算結果が同一になるとは限りません。<BR>
なぜならば、変換は正確に行われるとは限らないからです。<BR>
<BR>
※ /op _ Consistent FP results<BR>
一貫した浮動少数演算の結果を返す？<BR>
<BR>
※ /oe _ ???<BR>
小規模なユーザ定義関数の呼出を生成するかわりに、関数をインラインに展開します。<BR>
関数をインラインに展開することで、関数の呼出が生成されたことを検出する方法を<BR>
最適化するよりも効率よく、コードを実行することができます。<BR>
 <BR>
※ /s _ Disable stack depth checking<BR>
スタックオーバフローの確認を生成しない。<BR>
<BR>
※ /ei _ Force enums to be type int<BR>
すべての列挙型について少なくとも”int”を割り当てます。 <BR>
<BR>
/or オプションは、PentiumおよびPentium Proプロセッサにおいて<BR>
高速なコードを生成するのに、非常に重要なものとなります。<BR>
<BR> 
ある環境下では、”ob”と”ol+”による最適化が32ビットインテルコードに<BR>
よりよい性能をもたらすことがあります。 <BR>
<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/12/18 OpenWatcom C/C++ 1.9のバグ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
作成したプログラムがVCでは正常に動作するがWCだと動作しないので<BR>
徹底的に調べた結果、オプション -ml (-ox 含む)を付けて以下のコードを<BR>
ビルドすると本来は"20"となる処理が"25"になってしまうバグを突き止めた。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
void loop_c()<BR>
{<BR>
&ensp;int i;<BR>
&ensp;int counter = 0;<BR>
&ensp;int flag = 0x0004;<BR>
&ensp;int al[21];<BR>
<BR>
&ensp;if( flag & 0x01 )<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 6; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 5;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;else<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 6; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 10;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;if( flag & 0x02 )<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 11; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 15;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;else<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 11; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 20;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;if( flag & 0x04 )<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 16; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 25;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;else<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 16; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 30;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;if( flag & 0x08 )<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 21; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 35;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
&ensp;else<BR>
&ensp;{<BR>
&ensp;&ensp;for( ; counter < 21; counter++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;al[counter] = 40;<BR>
&ensp;&ensp;}<BR>
&ensp;}<BR>
<BR>
&ensp;for( i=0;i<21;i++ )<BR>
&ensp;{<BR>
&ensp;&ensp;printf( "[%d]\n",al[i] );<BR>
&ensp;}<BR>
}<BR>

</TD>
</TR>
</TABLE>

<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/11/09 Win32 ミリ精度の設定</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows で timeBeginPeriod() を使うと Sleep()、GetTickCount() や<BR>
マルチメディアタイマーの最小精度を設定する事ができる。<BR>
（timeGetTime() は timeBeginPeriod() の使用に関わらず常に高精度らしい。）<BR>
<BR>
しかし、timeBeginPeriod() は OS (Windows 本体) に対して設定されるので<BR>
他のプロセスもこの精度で動作するようになる。<BR>
（複数のプロセスから使用された場合には低い値（高精度）が優先されるらしい。）<BR>
<BR>
Windows Vista 以降は AvSetMmThreadCharacteristics() が追加され、<BR>
この AvSetMmThreadCharacteristics() を使用した場合にはカレントスレッドの<BR>
精度のみが変更される…らしい。<BR>
<BR>
Windows Vista 以降でしか動作しなくなるが他のプロセス、スレッドに影響を<BR>
与えないと言う意味では行儀の良いソフトと言えるのかもしれない。<BR>
<BR>
ただし、Windows SDK の avrt.h と avrt.lib が必要になる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/09/25 Win32 レジスタ退避</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Windows の 関数呼び出しでは eax,ecx,edx の値は保持されない。<BR>
<BR>
ebx,edi,esi 等は値が保持される。<BR>
<BR>
当然ながら全ての関数はこのルールを守る必要がある。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/08/07 VCのアセンブラ出力の確認</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
メニュー「プロジェクト」→「設定」→「C/C++」タブ→<BR>
「リスティング ファイル タイプ」を「ソースコード含む」に変更する。<BR>
（オプションに直接 /FAs を追加でもいい。）<BR>
<BR>
ビルドすれば出力フォルダにアセンブラのソースが出力される。<BR>
<BR>
コンパイラ最適化の確認やコンパイラのバグ探しに有効。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/08/06 x86 FPUアセンブラ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
FPU でコードを記述する場合は逆ポーランド記法を使うと良い。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
float fpu_sample(float a, float b, float c, float d)<BR>
{<BR>
&ensp;float ans;<BR>
&ensp;//ans = (a + b) * (c - d);<BR>
&ensp;// 逆ポーランド記法では上の式は 「ab+cd-*」 となる<BR>
&ensp;_asm<BR>
&ensp;{<BR>
&ensp;&ensp;fld     a       // ;aをst(0)にプッシュ<BR>
&ensp;&ensp;fadd    b       // ;st(0) = st(0) + b<BR>
&ensp;&ensp;fld     c       // ;cをst(0)にプッシュ、先ほどのst(0)はst(1)となる<BR>
&ensp;&ensp;fsub    d       // ;st(0) = st(0) - d<BR>
&ensp;&ensp;fmul            // ;st(1) = st(1) * st(0)<BR>
&ensp;&ensp;&ensp;&ensp;        // ;st(0)はポップされ、st(1)がst(0)として残る<BR>
&ensp;&ensp;fstp    ans     // ;ansに値を格納する<BR>
&ensp;}<BR>
&ensp;return ans;<BR>
}</TD>
</TR>
</TABLE>
<BR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2011/02/06 64ビット変数</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
<BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">コンパイラ</TD>
<TD WIDTH="70">定義</TD>
<TD WIDTH="300">備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++</TD>
<TD>__int64</TD>
<TD>VisualStudio 2005 以降なら long long も使える？</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++</TD>
<TD>__int64</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Watcom C++</TD>
<TD>__int64</TD>
<TD>OpenWatcom 1.9 なら long long も使える。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>GCC</TD>
<TD>long long</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">定義</TD>
<TD WIDTH="150">printf 系</TD>
<TD WIDTH="150">サフィックス</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>__int64</TD>
<TD>%I64d、%I64i、%I64u、<BR>%I64x、%I64X</TD>
<TD>i64、I64、ui64、UI64</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>long long</TD>
<TD>%lld、%lli、%llu、<BR>%llx、%llX</TD>
<TD>-</TD>
</TR>
</TABLE>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/12/04 continue 文</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
continue の動き(飛び)方。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
c = 0;<BR>
do<BR>
{<BR>
&ensp;c++;<BR>
&ensp;continue;	// do に行かず while に飛ぶ<BR>
&ensp;printf( "end\n" );<BR>
}<BR>
while( c &lt; 10 );<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
c = 0;<BR>
do<BR>
{<BR>
&ensp;c++;<BR>
&ensp;switch( c )<BR>
&ensp;{<BR>
&ensp;&ensp;case 100:	//dummy<BR>
&ensp;&ensp;&ensp;break;<BR>
&ensp;&ensp;default:<BR>
&ensp;&ensp;&ensp;printf( "switch(%d)\n",c );<BR>
&ensp;&ensp;&ensp;continue;	// switch を無視して飛ぶ<BR>
&ensp;}<BR>
&ensp;printf( "end\n" );<BR>
}<BR>
while( c &lt; 10 );<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/11/27 １次元配列から多重配列へのキャスト</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
キャスト。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
void func1( int v[][10] )<BR>
{<BR>
&ensp;int i,k;<BR>
&ensp;int (*p)[10] = v;<BR>
&ensp;for( i=0;i<2;i++ )<BR>
&ensp;{<BR>
&ensp;&ensp;for( k=0;k<10;k++ )<BR>
&ensp;&ensp;{<BR>
&ensp;&ensp;&ensp;printf( "%d,",p[i][k] );<BR>
&ensp;&ensp;}<BR>
&ensp;&ensp;printf( "\n" );<BR>
&ensp;}<BR>
}<BR>
<BR>
void main()<BR>
{<BR>
&ensp;int val[20]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};<BR>
<BR>
&ensp;func1( (int (*)[10])val );<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/11/06 テクスチャアトラス</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
1つにまとめた画像をテクスチャアトラスと呼ぶらしい。<BR>
<BR>
複数のテクスチャを glBindTexture で切り替えるよりも画像を1つにまとめて<BR>
テクスチャ座標で指定（切り替え）した方が処理が速くなる。<BR>
<BR>
これは DirectX でも同様らしい。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/10/29 四角形を3Dで描画する</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
下の図のような頂点 ABCD の四角形を描画する。<BR>
頂点の順番で右回りと左回りで面の裏表が変わるので<BR>
座標系( OpenGL と Direct3D では異なる。)に合わせて選択する。<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>
<TR BGCOLOR="#000088">
<TD ALIGN="RIGHT">A</TD>
<TD></TD>
<TD ALIGN="LEFT">B</TD>
</TR>
<TR BGCOLOR="#000088">
<TD></TD>
<TD BGCOLOR="#ffff00" WIDTH="100" HEIGHT="100"></TD>
<TD></TD>
</TR>
<TR BGCOLOR="#000088">
<TD ALIGN="RIGHT">D</TD>
<TD></TD>
<TD ALIGN="LEFT">C</TD>
</TR>
</TABLE>
<BR>
TRIANGLE_STRIP で描画する場合は<BR>
ABDC もしくは ADBC の順番で頂点を指定する。<BR>
<BR>
POLYGON,QUAD で描画する場合は<BR>
ABCD もしくは ADCB の順番で頂点を指定する。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/10/10 mfc100.dll</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
「mfc100.dll が見つからなかったため、アプリケーションを開始できませんでした。」と<BR>
エラーが出た場合は VC++ 2010 再配布パッケージをインストールすると解決する。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="160">VC製品バージョン</TD>
<TD WIDTH="70">MFC</TD>
<TD WIDTH="300">備考</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Microsoft C/C++ 7.0</TD>
<TD>MFC 1.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 1.0</TD>
<TD>MFC 2.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 2.0</TD>
<TD>MFC 3.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 2.1</TD>
<TD>MFC 3.1</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 2.2</TD>
<TD>MFC 3.2</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.0</TD>
<TD>MFC 4.0</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.1</TD>
<TD>MFC 4.1</TD>
<TD>-</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.2</TD>
<TD>MFC 4.2</TD>
<TD>mfc42.dll</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 5.0</TD>
<TD>MFC 4.21</TD>
<TD>mfc42.dll</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 6.0</TD>
<TD>MFC 6.0</TD>
<TD>mfc42.dll</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ .NET 2002</TD>
<TD>MFC 7.0</TD>
<TD>mfc70.dll</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ .NET 2003</TD>
<TD>MFC 7.1</TD>
<TD>mfc71.dll</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ .NET 2005</TD>
<TD>MFC 8.0</TD>
<TD>mfc80.dll<BR>VC++ 2005再配布パッケージに含まれる。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ .NET 2008</TD>
<TD>MFC 9.0</TD>
<TD>mfc90.dll<BR>VC++ 2008再配布パッケージに含まれる。</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ .NET 2010</TD>
<TD>MFC 10.0</TD>
<TD>mfc100.dll<BR>VC++ 2010再配布パッケージに含まれる。</TD>
</TR>
</TABLE>
<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/09/29 float の無効値</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC のデバッガで float 型が「1.#IND000000000000」と表示される。<BR>
<BR>
IND → 計算結果が無効な値？<BR>
INF → 計算結果が無効な値？<BR>
NaN → 計算結果が無限大。<BR>
<BR>
オーバーフローした時になるらしい。<BR>
IND と INF の違いは？<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/09/24 多重インクルードの回避</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
複数回インクルードされるのを防ぐプリプロセッサ。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#ifndef __HOGE_H__<BR>
#define __HOGE_H__<BR>
～宣言～<BR>
#endif	// __HOGE_H__<BR>
</TD>
</TR>
</TABLE>
<BR>
上の記述と同等のプラグマ。(ただし、コンパイラ依存)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#pragma once<BR>
～宣言～<BR>
</TD>
</TR>
</TABLE>
<BR>
この２つを合わせて使っても意味はない。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/09/09 タイマー精度 (winmm.lib)</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
何もしない状態だと Sleep(1) としても 1ms を<BR>
大幅に超える時間が経過した後に処理が終了する。<BR>
timeBeginPeriod(1) を実行すると最小単位が 1ms となるので<BR>
Sleep(1) での動作が改善される。<BR>
<BR>
この影響を受ける関数↓は他にもあるかも知れない。<BR>
timeSetEvent(),Sleep(),GetTickCount(),timeGetTime()<BR>
<BR>
しかも timeBeginPeriod() は OS で共通の設定っぽい。<BR>
<BR>
WindowsXP ではソフトＡで timeBeginPeriod(1) を実行し、<BR>
ソフトＢで Sleep(1) を実行しても 1ms となり効果はある。<BR>
ただし、ソフトＡを終了し、 timeEndPeriod(1) が呼ばれた後に<BR>
ソフトＢで Sleep(1) を実行した場合には 1ms で動作しなくなる。<BR>
<BR>
なお、最近のPCでは timeBeginPeriod(1) としても問題ないが<BR>
timeGetDevCaps() で設定可能な最小値を取得して<BR>
設定するのが正しい実装。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/09/01 古い関数の警告を発生させる</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Visual Studio 2005 以降で strcpy 等の標準関数を使うと<BR>
「warning C4996: 'strcpy' が古い形式として宣言されました。」と<BR>
警告が発生するけどこれは deprecated が定義されているから。<BR>
<BR>
つまり deprecated を使えば同じ事が実現できるけど VC2005 と gcc では構文が違う。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#if defined(MSC_VER)<BR>
// VC++<BR>
__declspec(deprecated("*** This function should not be used.")) void old_func();<BR>
#else<BR>
// GCC<BR>
void old_func () __attribute__ ((deprecated));<BR>
#endif<BR>
</TD>
</TR>
</TABLE>

<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/08/25 無効ヒープ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC のデバッグ版で実行した時に出たエラーログ。<BR>
<BR>
HEAP[test.exe]: Invalid address specified to RtlValidateHeap( 00260000, 0012F5A4 )<BR>
<BR>
主に exe と dll でリンクしている CRT が違う場合にヒープが異なる為に発生する問題。<BR>
<BR>
それ以外にもスタック変数を delete しても起きる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/08/24 メモリアクセス違反</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC のデバッグ版で実行した時に出たエラーログ。<BR>
<BR>
Heap block at 0024A0F0 modified at 0024B2F8 past requested size of 1200<BR>
<BR>
0x0024A0F0 番地に確保されたヒープブロックにおいて、確保したサイズ"1200"を超えた<BR>
0x0024B2F8 番地が変更されたらしい。<BR>
<BR>
●考えられる原因<BR>
・そもそも確保したメモリサイズが少ない。<BR>
・確保したメモリ以上の範囲でループを回してしまった。<BR>
・構造体のサイズを間違えている。（アライメントの影響とか。）<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/08/21 スタックのアライメント</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
コンパイラに AUTO 変数のアドレスが奇数にならないように支持する。<BR>
<FONT COLOR="#ff0000">奇数アドレスのアクセス制限は 2010/05/21 を参照。</FONT><BR>
<BR>
VC6 だとこんな感じで使える。（SP6からのサポート）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#define ALIGNED __declspec(align(16))<BR>
<BR>
ALIGNED float temp[4]<BR>
<BR>
<BR>
struct __declspec(align(16)) OPT_BUFFER<BR>
{<BR>
&ensp;&ensp;char buffer[8];<BR>
&ensp;&ensp;int size;<BR>
};<BR>
</TD>
</TR>
</TABLE>
<BR>

VC6 と gcc では構文が違うのでマクロとか。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#if defined(MSC_VAR)<BR>
&ensp;#define ATTRIBUTE_ALIGN(n) __declspec(align(n))<BR>
#else<BR>
&ensp;#define ATTRIBUTE_ALIGN(n) __attribute__((aligned(n)))<BR>
#endif<BR>
</TD>
</TR>
</TABLE>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/06/19 コンパイラ バージョン</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Microsoft (_MSC_VER)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>MS C 6.0</TD>
<TD>600</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>MS C/C++ 7.0</TD>
<TD>700</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 1.0</TD>
<TD>800</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 2.0</TD>
<TD>900</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.0</TD>
<TD>1000</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.1</TD>
<TD>1010</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 4.2</TD>
<TD>1020</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 5.0 (VS 97)</TD>
<TD>1100</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 6.0 (VS 6.0)</TD>
<TD>1200</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 7.0 (VS 2002)</TD>
<TD>1300</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 7.1 (VS 2003)</TD>
<TD>1310</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 8.0 (VS 2005)</TD>
<TD>1400</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 9.0 (VS 2008)</TD>
<TD>1500</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Visual C++ 10.0 (VS 2010)</TD>
<TD>1600</TD>
</TR>
</TABLE>
<BR>
<BR>

Borland (__TURBOC__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Turbo C 2.0</TD> <!-- 0x200 -->
<TD>0x18d</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Turbo C++ 1.01</TD>
<TD>0x296</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Turbo C++ for Win3.1</TD>
<TD>0x400</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Turbo C++ 4.0</TD>
<TD>0x452</TD>
</TR>
</TABLE>
<BR>
<BR>

Borland (__BORLANDC__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ 5.0</TD>
<TD>0x500</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ 5.51</TD>
<TD>0x551</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 1.0</TD>
<TD>0x520</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 3.0</TD>
<TD>0x530</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 6.0</TD>
<TD>0x560</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 2009</TD>
<TD>0x610</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 2010</TD>
<TD>0x620</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Borland C++ Builder 2010<BR>Update 2</TD>
<TD>0x621</TD>
</TR>
</TABLE>
<BR>
<BR>

Watcom (__WATCOMC__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Watcom C++ 10.5</TD>
<TD>1050</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Watcom C++ 11.0</TD>
<TD>1100</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenWatcom 1.1</TD>
<TD>1210</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenWatcom 1.4</TD>
<TD>1240</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>OpenWatcom 1.9</TD>
<TD>1290</TD>
</TR>
</TABLE>
<BR>
<BR>

Intel (__INTEL_COMPILER)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Intel Compiler 6.0</TD>
<TD>600</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>Intel Compiler 11.0</TD>
<TD>1100</TD>
</TR>
</TABLE>
<BR>
<BR>

Metrowerks (__MWERKS__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>CodeWarrior 7.0</TD>
<TD>(__MWERKS__ & 0xFF00) == 0x2400</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>CodeWarrior 8.0</TD>
<TD>(__MWERKS__ & 0xFF00) == 0x3000</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>CodeWarrior 9.0</TD>
<TD>(__MWERKS__ & 0xFF00) == 0x3200</TD>
</TR>
</TABLE>
<BR>
<BR>

gcc (__GNUC__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>GNU C/C++ 2.7.0</TD>
<TD>__GNUC__ 2<BR>__GNUC_MINOR__ 7<BR>__GNUC_PATCHLEVEL__ 0</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>GNU C/C++ 3.0.2</TD>
<TD>__GNUC__ 3<BR>__GNUC_MINOR__ 0<BR>__GNUC_PATCHLEVEL__ 2</TD>
</TR>
</TABLE>
<BR>
<BR>

MinGW (__MINGW32__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>MinGW 2.4</TD>
<TD>__MINGW32_MAJOR_VERSION 2<BR>__MINGW32_MINOR_VERSION 4</TD>
</TR>
</TABLE>
<BR>
<BR>

DJGPP (__DJGPP__)<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR BGCOLOR="#505050">
<TD WIDTH="180">コンパイラ</TD>
<TD>数値</TD>
</TR>
<TR BGCOLOR="#008888">
<TD>DJGPP 2.01</TD>
<TD>__DJGPP__ 2<BR>__DJGPP_MINOR__ 1</TD>
</TR>
</TABLE>
<BR>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/05/22 volatile</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
コンパイラには必ずメモリにアクセスするコードを生成するように指示する。<BR>
マルチスレッドや割り込みのコーディングで必要になる。<BR>
<BR>
問題のコード。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
int x = 0;<BR>
int flag = 1;  // 別スレッドから書き換える<BR>
<BR>
while( <FONT COLOR="#ff0000">flag</FONT> )<BR>
{<BR>
&ensp;&ensp;x++;<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>

コンパイラが最適化すると…<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
int x = 0;<BR>
<BR>
while( <FONT COLOR="#ff0000">1</FONT> )  // 最適化でメンバ変数が抹消され、無限ループになる。<BR>
{<BR>
&ensp;&ensp;x++;<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>
対策コード。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
int x = 0;<BR>
volatile int flag = 1;  // 必ずメモリを参照する<BR>
<BR>
while( flag )<BR>
{<BR>
&ensp;&ensp;x++;<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>
volatile で最適化されなくなる。<BR>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/05/21 UNALIGNED と __unaligned</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
UNALIGNED キーワードを使うとコンパイラが<BR>
奇数アドレスへのアクセスを意識したコードを生成する。<BR>
ただし、余計なコードが生成されるので速度は低下する。<BR>
<BR>
x86 では不要だけど RISC 系 CPU (SH4,MIPS)では必要。<BR>
<BR>
問題のコード。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
char c[8];<BR>
int* p;<BR>
int q;<BR>
<BR>
p = (int*)&c[1];<BR>
<BR>
q = *p; // 例外が発生する<BR>
</TD>
</TR>
</TABLE>
<BR>

対策コード。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
char c[8];<BR>
UNALIGNED int* p;   // UNALIGNEDを宣言<BR>
int q;<BR>
<BR>
p = (UNALIGNED int*)&c[1];<BR>
<BR>
q = *p; // 例外が発生しなくなる<BR>
</TD>
</TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/02/27 "#ifdef xyz" と "#if defined(xyz)"</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
● defined(xyz) の利点<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#if defined(xyz1) || defined(xyz2)<BR>
　～<BR>
#endif<BR>
</TD>
</TR>
</TABLE>

<BR>
と複数の定義を or や and 条件で比較して記述できる。<BR>
<BR>
また、複数の連続条件判定もできる。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
#if defined(xyz1)<BR>
　～<BR>
#elif defined(xyz2)<BR>
　～<BR>
#endif<BR>
</TD>
</TR>
</TABLE>

<BR>
これらは全て #ifdef では実現できない。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/02/22 VC のC++規格対応度</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
未だに VC6 を使っている人は多いのではないかとと思ったり。<BR>
<BR>
VC の C99 サポートは VC++2005 で使用可能？<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2010/01/04 DllMain の制約</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
DllMain でやってはイケないこと。<BR>
<BR>
●DllMain の中で 再度 DllMain が呼ばれる実装<BR>
ローダは DllMain を実行する前にロックをかけるので以下の API を<BR>
DllMain で呼び出すとデッドロックしてしまう。<BR>
・LoadLibrary 系<BR>
・GetModuleHandle 系<BR>
・スレッド操作系 + CriticalSection 系<BR>
<BR>
●DllMain の中で Kernel32 以外の API の使用禁止<BR>
DllMainが実行された段階で user32.dll/gdi32.dll 等の DLL の<BR>
初期化が完了していないケースが存在し、例外（アクセス違反）が<BR>
発生する可能性がある。<BR>
<BR>
●マネージドコードの使用禁止<BR>
C#<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2009/12/29 VC ftol の実装</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Visual C++ 2002 以降では float/double から__int64/int の変換に_ftol2 を使い、<BR>
2005 以降では更に float/double から int の変換に _ftol2_sse を試行した後<BR>
_ftol2 を使用する。<BR>
これらの関数の中では浮動小数点制御ワードの変更を行わず切り捨てを実現する。<BR>
_ftol2 の中では浮動小数点のビット表現を利用した計算のみで切り捨てを行う。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2009/11/09 VC6 で ftol2 のリンクエラー</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
最新のVC用のライブラリをリンクしたりすると発生する。<BR>
ftol2 で望んでいる結果は ftol と同じなので以下のコードで<BR>
問題を回避出来る。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
extern "C" long _ftol2( double dblSource )<BR>
{<BR>
&ensp;&ensp;return _ftol( dblSource );<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2009/10/17 VC6 SP6</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
Visual C++ 6.0 SP6 はパッチ無し状態と比べて約 10KB ほど大きな実行ファイルを<BR>
生成する。<BR>
<BR>
CRT ライブラリもしくはスタートアップのコードが大きくなったと思われる。<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>


<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2009/10/11 VC6 Tiny EXE</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
この大容量化した時代に需要があるとは思えないが…。<BR>
<BR>
Ｃランタイムを使わなければ数十KB、サイズが小さくなるというやつです。<BR>
<BR>
これを行うと exe のサイズは小さくなりますが、<BR>
代償としてＣランタイム＋αの機能が使えなくなります。<BR>
（C++の主要機能も使えなくなるようです。）<BR>
<BR>
<BR>
●とりあえず発生する制限を回避する方法。<BR>
<BR>
・浮動少数から整数へのキャスト → _ftol が無いとリンカでエラーになる。<BR>
　(コンパイラは _ftol を呼び出すコードを生成する)<BR>
<BR>
対象方法は２つ。<BR>
→ ftol 相当の関数をＣで実装し、キャストを全て自作関数に置き換える<BR>
→ _ftol を実装する。（要アセンブラ）<BR>
<BR>
↓は IEEE754 フォーマット処理が面倒なのでインラインアセンブラで手抜きの例。<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
/*<BR>
ftol 関数では、浮動小数点型から整数型への変換に加えて、<BR>
浮動小数点制御ワードのビット 10 と 11 を設定して、<BR>
FPU (Floating-Point Unit) の丸めモードをゼロ (切り捨て) にします。<BR>
したがって、浮動小数点型から整数型への変換は、ANSI C 規格どおりに行われ、<BR>
小数部分を破棄することが保証されます。<BR>
*/<BR>
EXTERN_C int _fltused = 0x9875;	// 合わせて必要(ランタイムライブラリで使用される)<BR>
long __cdecl _ftol(float f)<BR>
{<BR>
	long x;<BR>
#if 0<BR>
	// x87 丸めモードのビットは考慮しないのでどれになるか保証できない<BR>
	// ・一番近い値に丸める (中間の場合は偶数)。<BR>
	// ・負の無限大に丸める。<BR>
	// ・正の無限大に丸める。<BR>
	// ・ゼロに丸める。<BR>
	float temp = 0.5f;<BR>
	_asm<BR>
	{<BR>
		fld		dword ptr [f]		; 少数ロード<BR>
		fsub	dword ptr [temp]	; 0.5を引いて<BR>
		fistp	dword ptr [x]		; 整数ストア<BR>
	}<BR>
#else<BR>
	short temp1;	// ビット初期状態<BR>
	short temp2;	// ビット変更状態<BR>
	_asm<BR>
	{<BR>
		fld		dword ptr [f]		; 少数ロード<BR>
		wait						; コプロ完了待ち<BR>
		fnstcw	word ptr [temp1]	; バックアップ<BR>
		wait						; コプロ完了待ち<BR>
		mov		ax,word ptr [temp1]	; レジスタに移す<BR>
		or		ah,0Ch				; ビット立てる(ANSI 準拠)<BR>
		mov		word ptr [temp2],ax	; 代入<BR>
		fldcw	word ptr [temp2]	; モード変更<BR>
		fistp	dword ptr [x]		; 整数ストア<BR>
		fldcw	word ptr [temp1]	; 元に戻す<BR>
	}<BR>
#endif<BR>
	return x;<BR>
}<BR>
</TD>
</TR>
</TABLE>
<BR>
<BR>
・大きな配列の AUTO 変数を引数で渡す → _chkstk が無いとリンカでエラーになる。<BR>
<BR>
対象方法は２つ。<BR>
→ AUTO 変数を static にしてしまう。<BR>
→ _chkstk を実装する。（要アセンブラ）<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR>
<TD WIDTH="588" BGCOLOR="#008888">
chkstk.asm / .obj って Enterprise Edition にしか入ってないみたい…？<BR>
<BR>
海外サイトを探すと chkstk のソースはあるんだけど、<BR>
MASM 6.14 でアセンブルしても正常に実行できない。<BR>
<BR>
なので文法を NASM に書き換えてアセンブルすればビルドできる。<BR>
</TD>
</TR>
</TABLE>
<BR>

</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2007/xx/xx 静的クラスのコンストラクタ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC6 の仕様らしいが…<BR>
<BR>
クラスのインスタンスを static で生成すると VC6 では困った動作になる。<BR>
・デバッグ版でビルドするとコンストラクタは呼ばれる。<BR>
・リリース版でビルドするとコンストラクタが<FONT COLOR="#ff0000">呼ばれない</FONT>。<BR>
<BR>
gcc とか他のコンパイラはどうなんだろ？<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2007/02/20 afxres.h</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
環境を変えたらリソーススクリプトで afxres.h が存在しないと<BR>
エラーが出てビルドが通らなくなった。<BR>
<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
fatal error RC1015: cannot open include file 'afxres.h'.<BR>
</TD></TR>
</TABLE>
<BR>
調べてみるとＭＦＣのヘッダファイルらしい。<BR>
そういえばインストールの時にＭＦＣのチェックを外したな…<BR>
<BR>
Express Edition はＭＦＣが付属していないので同様の問題が発生する。<BR>
<BR>
とりあえずこんな感じで修正すればビルドは通るが…<BR>
<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5>
<TR><TD WIDTH="588" BGCOLOR="#008888">
//#include "afxres.h"<BR>
#include "windows.h"<BR>
#define IDC_STATIC -1<BR>
</TD></TR>
</TABLE>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2006/05/04 Opteron Rev.F の新命令</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
RDTSCP<BR>
　RDTSCPは、RDTSCを改良した命令です。<BR>
RDTSCは1命令で1増加するカウンタであるTSCを読み込む命令です。<BR>
AMD x86_64では実行しているCPUによって TSC の値が変わってしまうという問題が<BR>
ありました。<BR>
<BR>
　 RDTSCP命令はTSCだけでなく、同時にTSC_AUX領域の中身も読み込みます。<BR>
TSC_AUX領域はCPUごとに違う値を持たせることができるので、<BR>
CPU番号などを埋め込んでおけば、どのCPUで命令が実行されているのかを<BR>
確認できます。 <BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2006/04/16 ウワサ</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
SetThreadAffinityMask() が機能しないことがあるらしい。<BR>
<BR>
開発環境が VC Enterprise Edition でないと完璧な動作はしないとか…。<BR>
事実ならスタートアップ・モジュールが違うのかな？ <BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<TABLE BORDER=1 CELLSPACING=1 CELLPADDING=5 WIDTH="624">
<TR>
<TD COLSPAN=1 BGCOLOR="#333388">
<FONT COLOR="#00AAFF">2005/01/27 WinMainCRTStartup</FONT></TD>
</TR>
<TR>
<TD BGCOLOR="#222288">
VC のスタートアップ・モジュール。<BR>
<BR>
実行時にＣランタイムライブリの初期化等を実行した後に<BR>
WinMain を呼び出す関数。<BR>
<BR>
コンパイラ(ソフト)が変わると名称も変わるらしい。<BR>
Borland は当然、別の名称を使っている？<BR>
<BR>
</TD>
</TR>
</TABLE>
<BR><BR>

<BR><HR><BR>
<A HREF="index.html" TARGET="_top">Back</A> (だるだる団)<BR>
<BR><BR><BR>
</BODY>
</HTML>
